var documenterSearchIndex = {"docs":
[{"location":"pair_production/#Structure","page":"Pair_Production","title":"Structure","text":"","category":"section"},{"location":"pair_production/","page":"Pair_Production","title":"Pair_Production","text":"Radiant.Pair_Production","category":"page"},{"location":"pair_production/#Radiant.Pair_Production","page":"Pair_Production","title":"Radiant.Pair_Production","text":"Pair_Production\n\nStructure used to define parameters for production of multigroup pair production cross-sections.\n\nMandatory field(s)\n\nN/A\n\nOptional field(s) - with default values\n\ninteraction_types::Dict{Tuple{String,String},Vector{String}} = Dict((\"photons\",\"photons\") => [\"A\"],(\"photons\",\"electrons\") => [\"P\"],(\"photons\",\"positrons\") => [\"P\"]): Dictionary of the interaction processes types, of the form (incident particle,outgoing particle) => associated list of interaction type, which values correspond:\n(\"photons\",\"photons\") => [\"A\"]: absorption of incoming photon.\n(\"photons\",\"electrons\") => [\"P\"]: produced electron.\n(\"photons\",\"positrons\") => [\"P\"]: produced positron.\nangular_scattering_type::String=modified_dipole: type of angular scattering, which can takes the following values:\nangular_scattering_type = modified_dipole: modified dipôle distribution, based on Poskus (2019) shape functions.\nangular_scattering_type = sommerfield: Sommerfield distribution.\n\n\n\n\n\n","category":"type"},{"location":"pair_production/#Methods","page":"Pair_Production","title":"Methods","text":"","category":"section"},{"location":"pair_production/","page":"Pair_Production","title":"Pair_Production","text":"Radiant.set_interaction_types(this::Radiant.Pair_Production,interaction_types::Dict{Tuple{String,String},Vector{String}})\nRadiant.set_angular_scattering_type(this::Radiant.Pair_Production,angular_scattering_type::String)","category":"page"},{"location":"pair_production/#Radiant.set_interaction_types-Tuple{Pair_Production,Dict{Tuple{String,String},Array{String,1}}}","page":"Pair_Production","title":"Radiant.set_interaction_types","text":"set_interaction_types(this::Pair_Production,interaction_types::Dict{Tuple{String,String},Vector{String}})\n\nTo define the interaction types for pair production processes.\n\nInput Argument(s)\n\nthis::Pair_Production: pair production structure.\ninteraction_types::Dict{Tuple{String,String},Vector{String}}: Dictionary of the interaction processes types, of the form (incident particle,outgoing particle) => associated list of interaction type, which can be:\n(\"photons\",\"photons\") => [\"A\"]: absorption of incoming photon.\n(\"photons\",\"electrons\") => [\"P\"]: produced electron.\n(\"photons\",\"positrons\") => [\"P\"]: produced positron.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> pair_production = Pair_Production()\njulia> pair_production.set_interaction_types( Dict((\"electrons\",\"electrons\") => [\"S\"]) ) # Only electron scattering, with photon absorption.\n\n\n\n\n\n","category":"method"},{"location":"pair_production/#Radiant.set_angular_scattering_type-Tuple{Pair_Production,String}","page":"Pair_Production","title":"Radiant.set_angular_scattering_type","text":"set_angular_scattering_type(this::Pair_Production,angular_scattering_type::String)\n\nTo define the pair_production photons angular distribution.\n\nInput Argument(s)\n\nthis::Pair_Production: pair_production structure.\nangular_scattering_type::String: angular scattering type.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> pair_production = Pair_Production()\njulia> pair_production.set_angular_scattering_type(\"sommerfield\")\n\n\n\n\n\n","category":"method"},{"location":"fluorescence/#Structure","page":"Fluorescence","title":"Structure","text":"","category":"section"},{"location":"fluorescence/","page":"Fluorescence","title":"Fluorescence","text":"Radiant.Fluorescence","category":"page"},{"location":"fluorescence/#Radiant.Fluorescence","page":"Fluorescence","title":"Radiant.Fluorescence","text":"Fluorescence\n\nStructure used to define parameters for production of multigroup fluorescence cross-sections.\n\nMandatory field(s)\n\nN/A\n\nOptional field(s) - with default values\n\ninteraction_types::Dict{Tuple{String,String},Vector{String}} = Dict((\"photons\",\"photons\") => [\"P\"],(\"electrons\",\"photons\") => [\"P\"],(\"positrons\",\"photons\") => [\"P\"]): Dictionary of the interaction processes types, of the form (incident particle,outgoing particle) => associated list of interaction type, which values correspond:\n(\"photons\",\"photons\") => [\"P\"]: production of fluorescence following incident photon ionization of subshells (by photoelectric effect).\n(\"electrons\",\"photons\") => [\"P\"]: production of fluorescence following incident electrons ionization of subshells (by Møller interaction).\n(\"positrons\",\"photons\") => [\"P\"]: production of fluorescence following incident positrons ionization of subshells (by Bhabha interaction).\nηmin::Float64=0.001: minimum probability of the production of specific fluorescence photon following electron cascades.\n\n\n\n\n\n","category":"type"},{"location":"fluorescence/#Methods","page":"Fluorescence","title":"Methods","text":"","category":"section"},{"location":"fluorescence/","page":"Fluorescence","title":"Fluorescence","text":"Radiant.set_interaction_types(this::Radiant.Fluorescence,interaction_types::Dict{Tuple{String,String},Vector{String}})\nRadiant.set_minimum_probability(this::Radiant.Fluorescence,ηmin::Real)","category":"page"},{"location":"fluorescence/#Radiant.set_interaction_types-Tuple{Fluorescence,Dict{Tuple{String,String},Array{String,1}}}","page":"Fluorescence","title":"Radiant.set_interaction_types","text":"set_interaction_types(this::Fluorescence,interaction_types::Dict{Tuple{String,String},Vector{String}})\n\nTo define the interaction types for fluorescence processes.\n\nInput Argument(s)\n\nthis::Fluorescence: fluorescence structure.\ninteraction_types::Dict{Tuple{String,String},Vector{String}}: Dictionary of the interaction processes types, of the form (incident particle,outgoing particle) => associated list of interaction type, which can be:\n(\"photons\",\"photons\") => [\"P\"]: production of fluorescence following incident photon ionization of subshells (by photoelectric effect).\n(\"electrons\",\"photons\") => [\"P\"]: production of fluorescence following incident electrons ionization of subshells (by Møller interaction).\n(\"positrons\",\"photons\") => [\"P\"]: production of fluorescence following incident positrons ionization of subshells (by Bhabha interaction).\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> fluorescence = Fluorescence()\njulia> fluorescence.set_interaction_types( Dict((\"electrons\",\"photons\") => [\"P\"]) ) # Only cascades following Møller interactions.\n\n\n\n\n\n","category":"method"},{"location":"fluorescence/#Radiant.set_minimum_probability-Tuple{Fluorescence,Real}","page":"Fluorescence","title":"Radiant.set_minimum_probability","text":"set_minimum_probability(this::Fluorescence,ηmin::Real)\n\nTo define the minimum probability of a specific fluorescence production.\n\nInput Argument(s)\n\nthis::Fluorescence: fluorescence structure.\nηmin::Real: minimum probability of a specific fluorescence production.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> fluorescence = Fluorescence()\njulia> fluorescence.set_minimum_probability(0.1) # Only fluorescence photons with probability greater than 10%.\n\n\n\n\n\n","category":"method"},{"location":"fixed_source/#Structure","page":"Fixed_Sources","title":"Structure","text":"","category":"section"},{"location":"fixed_source/","page":"Fixed_Sources","title":"Fixed_Sources","text":"Radiant.Fixed_Sources","category":"page"},{"location":"fixed_source/#Radiant.Fixed_Sources","page":"Fixed_Sources","title":"Radiant.Fixed_Sources","text":"Fixed_Sources\n\nStructure used to define a collection of fixed sources and their properties.\n\nMandatory field(s)\n\nsources_list::Vector{Source}: list of VolumeSource or SurfaceSource sources.\ncross_sections: Cross_Sections structure.\ngeometry: Geometry structure.\nsolvers: Solvers structure.\n\nOptional field(s) - with default values\n\nN/A\n\n\n\n\n\n","category":"type"},{"location":"fixed_source/#Methods","page":"Fixed_Sources","title":"Methods","text":"","category":"section"},{"location":"fixed_source/","page":"Fixed_Sources","title":"Fixed_Sources","text":"Radiant.add_source(this::Radiant.Fixed_Sources,fixed_source::Union{Radiant.Surface_Source,Radiant.Volume_Source})","category":"page"},{"location":"fixed_source/#Radiant.add_source-Tuple{Fixed_Sources,Union{Surface_Source, Volume_Source}}","page":"Fixed_Sources","title":"Radiant.add_source","text":"add_source(this::Fixed_Sources,fixed_source::Union{Surface_Source,Volume_Source})\n\nTo add a surface or volume source to the Fixed_Sources structure.\n\nInput Argument(s)\n\nthis::Fixed_Sources: collection of fixed sources.\nfixed_source::Union{Surface_Source,Volume_Source}: volume or surface source.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> vs = Volume_Source()\njulia> ... # Define the volume source properties\njulia> fs = Fixed_Sources()\njulia> fs.add_source(vs)\n\n\n\n\n\n","category":"method"},{"location":"surface_source/#Structure","page":"Surface_Source","title":"Structure","text":"","category":"section"},{"location":"surface_source/","page":"Surface_Source","title":"Surface_Source","text":"Radiant.Surface_Source","category":"page"},{"location":"surface_source/#Radiant.Surface_Source","page":"Surface_Source","title":"Radiant.Surface_Source","text":"Surface_Source\n\nStructure used to define a directionnal boundary source and its properties.\n\nMandatory field(s)\n\nname::String: name (or identifier) of the Surface_Source structure.\nparticle::String: type of particle emitted.\nenergy_group::Int64: energy group index in which the particle are emitted.\ndirection::Vector{Float64}: direction cosine.\nlocation::String: boundary at which the source is located.\nboundaries::Vector{Float64}: boundaries of the source along each axis [in cm].\n\nOptional field(s) - with default values\n\nintensity::Float64=1.0: intensity [# particles/cm⁽ᴺ⁻¹⁾, where N is the geometry dimension].\n\n\n\n\n\n","category":"type"},{"location":"surface_source/#Methods","page":"Surface_Source","title":"Methods","text":"","category":"section"},{"location":"surface_source/","page":"Surface_Source","title":"Surface_Source","text":"Radiant.set_particle(this::Radiant.Surface_Source,particle::String)\nRadiant.set_intensity(this::Radiant.Surface_Source,intensity::Real)\nRadiant.set_energy_group(this::Radiant.Surface_Source,energy_group::Int64)\nRadiant.set_direction(this::Radiant.Surface_Source,direction::Vector{Float64})\nRadiant.set_location(this::Radiant.Surface_Source,location::String)\nRadiant.set_boundaries(this::Radiant.Surface_Source,axis::String,boundaries::Vector{Float64})","category":"page"},{"location":"surface_source/#Radiant.set_particle-Tuple{Surface_Source,String}","page":"Surface_Source","title":"Radiant.set_particle","text":"set_particle(this::Surface_Source,particle::String)\n\nTo define the source particle.\n\nInput Argument(s)\n\nthis::Surface_Source: surface source.\nparticle::String: type of particle, which can takes the following values:\nparticle = \"photons\": photons.\nparticle = \"electrons\": electrons.\nparticle = \"positrons\": positrons.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> ss = Surface_Source()\njulia> ss.set_particle(\"electrons\")\n\n\n\n\n\n","category":"method"},{"location":"surface_source/#Radiant.set_intensity-Tuple{Surface_Source,Real}","page":"Surface_Source","title":"Radiant.set_intensity","text":"set_intensity(this::Surface_Source,intensity::Real)\n\nTo define the intensity of the source.\n\nInput Argument(s)\n\nthis::Surface_Source: surface source.\nintensity::Float64: intensity [# particles/cmᴺ, where N is the geometry dimension]\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> ss = Surface_Source()\njulia> ss.set_intensity(100)\n\n\n\n\n\n","category":"method"},{"location":"surface_source/#Radiant.set_energy_group-Tuple{Surface_Source,Int64}","page":"Surface_Source","title":"Radiant.set_energy_group","text":"set_energy_group(this::Surface_Source,energy_group::Int64)\n\nTo define the energy of the source by setting the energy group in which they are produced.\n\nInput Argument(s)\n\nthis::Surface_Source: surface source.\nenergy_group::Int64: energy group index.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> ss = Surface_Source()\njulia> ss.set_energy_group(1)\n\n\n\n\n\n","category":"method"},{"location":"surface_source/#Radiant.set_direction-Tuple{Surface_Source,Array{Float64,1}}","page":"Surface_Source","title":"Radiant.set_direction","text":"set_direction(this::Surface_Source,direction::Vector{Float64})\n\nTo set a direction of the source.\n\nInput Argument(s)\n\nthis::Surface_Source: surface source.\ndirection::Vector{Float64}: director cosines [μ,η,ξ]\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> ss = Surface_Source()\njulia> ss.set_direction([1.0,0.0,0.0])\n\n\n\n\n\n","category":"method"},{"location":"surface_source/#Radiant.set_location-Tuple{Surface_Source,String}","page":"Surface_Source","title":"Radiant.set_location","text":"set_location(this::Surface_Source,location::String)\n\nTo set the location of the surface source.\n\nInput Argument(s)\n\nthis::Surface_Source: surface source.\nlocation::String: boundary on which the surface source is, which can takes the following value:\nboundary = \"x-\": the lower bound along x-axis\nboundary = \"x+\": the upper bound along x-axis\nboundary = \"y-\": the lower bound along y-axis\nboundary = \"y+\": the upper bound along y-axis\nboundary = \"z-\": the lower bound along z-axis\nboundary = \"z+\": the upper bound along z-axis\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> ss = Surface_Source()\njulia> ss.set_location(\"x-\")\n\n\n\n\n\n","category":"method"},{"location":"surface_source/#Radiant.set_boundaries-Tuple{Surface_Source,String,Array{Float64,1}}","page":"Surface_Source","title":"Radiant.set_boundaries","text":"set_boundaries(this::Surface_Source,axis::String,boundaries::Vector{Float64})\n\nTo define the boundaries of the source along the specified axis.\n\nInput Argument(s)\n\nthis::Surface_Source: surface source.\naxis::String: axis along which the boundaries are defined.\nboundaries::Vector{Float64}: boundaries of the source in accending order [in cm]\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> ss = Surface_Source()\njulia> ss.set_boundaries(\"x\",[1.0,3.0])\n\n\n\n\n\n","category":"method"},{"location":"rayleigh/#Structure","page":"Rayleigh","title":"Structure","text":"","category":"section"},{"location":"rayleigh/","page":"Rayleigh","title":"Rayleigh","text":"Radiant.Rayleigh","category":"page"},{"location":"rayleigh/#Radiant.Rayleigh","page":"Rayleigh","title":"Radiant.Rayleigh","text":"Rayleigh\n\nStructure used to define parameters for production of multigroup Rayleigh cross-sections.\n\nMandatory field(s)\n\nN/A\n\nOptional field(s) - with default values\n\ninteraction_types::Dict{Tuple{String,String},Vector{String}} = Dict((\"photons\",\"photons\") => [\"S\"]): Dictionary of the interaction processes types, of the form (incident particle,outgoing particle) => associated list of interaction type, which values correspond:\n(\"photons\",\"photons\") => [\"S\"]: elastic scattering of photons\n\n\n\n\n\n","category":"type"},{"location":"rayleigh/#Methods","page":"Rayleigh","title":"Methods","text":"","category":"section"},{"location":"rayleigh/","page":"Rayleigh","title":"Rayleigh","text":"","category":"page"},{"location":"inelastic_leptons/#Structure","page":"Inelastic_Leptons","title":"Structure","text":"","category":"section"},{"location":"inelastic_leptons/","page":"Inelastic_Leptons","title":"Inelastic_Leptons","text":"Radiant.Inelastic_Leptons","category":"page"},{"location":"inelastic_leptons/#Radiant.Inelastic_Leptons","page":"Inelastic_Leptons","title":"Radiant.Inelastic_Leptons","text":"Inelastic_Leptons\n\nStructure used to define parameters for production of multigroup inelastic collisional cross-sections for leptons.\n\nMandatory field(s)\n\nN/A\n\nOptional field(s) - with default values\n\ninteraction_types::Dict{Tuple{String,String},Vector{String}} = Dict((\"positrons\",\"positrons\") => [\"S\"],(\"positrons\",\"electrons\") => [\"P\"],(\"electrons\",\"electrons\") => [\"S\",\"P\"]): Dictionary of the interaction processes types, of the form (incident particle,outgoing particle) => associated list of interaction type, which values correspond:\n(\"positrons\",\"positrons\") => [\"S\"]: scattering of incident positrons\n(\"electrons\",\"electrons\") => [\"S\"]: scattering of incident electrons\n(\"positrons\",\"electrons\") => [\"P\"]: production of electrons by incident positrons\n(\"electrons\",\"electrons\") => [\"P\"]: production of electrons by incident electrons\n\n\n\n\n\n","category":"type"},{"location":"inelastic_leptons/#Methods","page":"Inelastic_Leptons","title":"Methods","text":"","category":"section"},{"location":"inelastic_leptons/","page":"Inelastic_Leptons","title":"Inelastic_Leptons","text":"Radiant.set_density_correction(this::Radiant.Inelastic_Leptons,density_correction::String)\nRadiant.set_is_shell_correction(this::Radiant.Inelastic_Leptons,is_shell_correction::Bool)\nRadiant.set_is_subshells_dependant(this::Radiant.Inelastic_Leptons,is_subshells_dependant::Bool)\nRadiant.set_interaction_types(this::Radiant.Inelastic_Leptons,interaction_types::Dict{Tuple{String,String},Vector{String}})","category":"page"},{"location":"inelastic_leptons/#Radiant.set_density_correction-Tuple{Inelastic_Leptons,String}","page":"Inelastic_Leptons","title":"Radiant.set_density_correction","text":"set_density_correction(this::Inelastic_Leptons,density_correction::String)\n\nSet the Fermi density correction.\n\nInput Argument(s)\n\nthis::Inelastic_Leptons: inelastic leptons structure.\ndensity_correction::String: type of density effect:\nfano: Fano density effect.\nsternheimer: Sternheimer semi-empirical density effect.\nnone: no density effect.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> elastic_leptons = Inelastic_Leptons()\njulia> elastic_leptons.set_density_correction(\"sternheimer\")\n\n\n\n\n\n","category":"method"},{"location":"inelastic_leptons/#Radiant.set_is_shell_correction-Tuple{Inelastic_Leptons,Bool}","page":"Inelastic_Leptons","title":"Radiant.set_is_shell_correction","text":"set_is_shell_correction(this::Inelastic_Leptons,is_shell_correction::Bool)\n\nActivate or desactivate shell correction for stopping powers.\n\nInput Argument(s)\n\nthis::Inelastic_Leptons: inelastic leptons structure.\nis_shell_correction::Bool: activate (true) or desactivate (false) the shell correction.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> elastic_leptons = Inelastic_Leptons()\njulia> elastic_leptons.set_is_shell_correction(false)\n\n\n\n\n\n","category":"method"},{"location":"inelastic_leptons/#Radiant.set_is_subshells_dependant-Tuple{Inelastic_Leptons,Bool}","page":"Inelastic_Leptons","title":"Radiant.set_is_subshells_dependant","text":"set_is_subshells_dependant(this::Inelastic_Leptons,is_subshells_dependant::Bool)\n\nCompute the inelastic cross-sections assuming bounded or unbounded electrons.\n\nInput Argument(s)\n\nthis::Inelastic_Leptons: inelastic leptons structure.\nis_subshells_dependant::Bool: bounded (true) or unbounded (false) electrons.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> elastic_leptons = Inelastic_Leptons()\njulia> elastic_leptons.set_is_subshells_dependant(false)\n\n\n\n\n\n","category":"method"},{"location":"inelastic_leptons/#Radiant.set_interaction_types-Tuple{Inelastic_Leptons,Dict{Tuple{String,String},Array{String,1}}}","page":"Inelastic_Leptons","title":"Radiant.set_interaction_types","text":"set_interaction_types(this::Inelastic_Leptons,interaction_types::Dict{Tuple{String,String},Vector{String}})\n\nTo define the interaction types for inelastic leptons processes.\n\nInput Argument(s)\n\nthis::Inelastic_Leptons: inelastic leptons structure.\ninteraction_types::Dict{Tuple{String,String},Vector{String}}: Dictionary of the interaction processes types, of the form (incident particle,outgoing particle) => associated list of interaction type, which can be:\n(\"positrons\",\"positrons\") => [\"S\"]: scattering of incident positrons\n(\"electrons\",\"electrons\") => [\"S\"]: scattering of incident electrons\n(\"positrons\",\"electrons\") => [\"P\"]: production of electrons by incident positrons\n(\"electrons\",\"electrons\") => [\"P\"]: production of electrons by incident electrons\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> elastic_leptons = Inelastic_Leptons()\njulia> elastic_leptons.set_interaction_types( Dict((\"electrons\",\"electrons\") => [\"S\"]) ) # No knock-on electrons.\n\n\n\n\n\n","category":"method"},{"location":"auger/#Structure","page":"Auger ","title":"Structure","text":"","category":"section"},{"location":"auger/","page":"Auger ","title":"Auger ","text":"Radiant.Auger","category":"page"},{"location":"auger/#Radiant.Auger","page":"Auger ","title":"Radiant.Auger","text":"Auger\n\nStructure used to define parameters for production of multigroup annihilation cross-sections.\n\nMandatory field(s)\n\nN/A\n\nOptional field(s) - with default values\n\ninteraction_types::Dict{Tuple{String,String},Vector{String}} = Dict((\"photons\",\"electrons\") => [\"P\"],(\"electrons\",\"electrons\") => [\"P\"],(\"positrons\",\"electrons\") => [\"P\"]): Dictionary of the interaction processes types, of the form (incident particle,outgoing particle) => associated list of interaction type, which values correspond:\n(\"photons\",\"electrons\") => [\"P\"]: production of Auger electron following incident photon ionization of subshells (by photoelectric effect).\n(\"electrons\",\"electrons\") => [\"P\"]: production of Auger electron following incident electrons ionization of subshells (by Møller interaction).\n(\"positrons\",\"electrons\") => [\"P\"]: production of Auger electron following incident positrons ionization of subshells (by Bhabha interaction).\nηmin::Float64=0.001: minimum probability of the production of specific Auger electrons following electron cascades.\n\n\n\n\n\n","category":"type"},{"location":"auger/#Methods","page":"Auger ","title":"Methods","text":"","category":"section"},{"location":"auger/","page":"Auger ","title":"Auger ","text":"Radiant.set_interaction_types(this::Radiant.Auger,interaction_types::Dict{Tuple{String,String},Vector{String}})\nRadiant.set_minimum_probability(this::Radiant.Auger,ηmin::Real)","category":"page"},{"location":"auger/#Radiant.set_interaction_types-Tuple{Auger,Dict{Tuple{String,String},Array{String,1}}}","page":"Auger ","title":"Radiant.set_interaction_types","text":"set_interaction_types(this::Auger,interaction_types::Dict{Tuple{String,String},Vector{String}})\n\nTo define the interaction types for Auger processes.\n\nInput Argument(s)\n\nthis::Auger: auger structure.\ninteraction_types::Dict{Tuple{String,String},Vector{String}}: Dictionary of the interaction processes types, of the form (incident particle,outgoing particle) => associated list of interaction type, which can be:\n(\"photons\",\"electrons\") => [\"P\"]: production of Auger electron following incident photon ionization of subshells (by photoelectric effect).\n(\"electrons\",\"electrons\") => [\"P\"]: production of Auger electron following incident electrons ionization of subshells (by Møller interaction).\n(\"positrons\",\"electrons\") => [\"P\"]: production of Auger electron following incident positrons ionization of subshells (by Bhabha interaction).\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> auger = Auger()\njulia> auger.set_interaction_types( Dict((\"electrons\",\"electrons\") => [\"P\"]) ) # Only cascades following Møller interactions.\n\n\n\n\n\n","category":"method"},{"location":"auger/#Radiant.set_minimum_probability-Tuple{Auger,Real}","page":"Auger ","title":"Radiant.set_minimum_probability","text":"set_minimum_probability(this::Auger,ηmin::Real)\n\nTo define the minimum probability of a specific Auger electron production.\n\nInput Argument(s)\n\nthis::Auger: auger structure.\nηmin::Real: minimum probability of a specific Auger electron production.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> auger = Auger()\njulia> auger.set_minimum_probability(0.1) # Only Auger electron with probability greater than 10%.\n\n\n\n\n\n","category":"method"},{"location":"computation_unit/#Structure","page":"Computation_Unit","title":"Structure","text":"","category":"section"},{"location":"computation_unit/","page":"Computation_Unit","title":"Computation_Unit","text":"Radiant.Computation_Unit","category":"page"},{"location":"computation_unit/#Radiant.Computation_Unit","page":"Computation_Unit","title":"Radiant.Computation_Unit","text":"Computation_Unit\n\nStructure used to consolidate the cross-sections, geometry, solvers and sources, execute transport calculations and extract its results.\n\nMandatory field(s)\n\ncross_sections::Cross_Sections: cross-section library.\ngeometry::Geometry: geometry.\nsolvers::Solvers: solvers.\nsources::Sources: fixed sources.\n\nOptional field(s) - with default values\n\nN/A\n\n\n\n\n\n","category":"type"},{"location":"computation_unit/#Methods","page":"Computation_Unit","title":"Methods","text":"","category":"section"},{"location":"computation_unit/","page":"Computation_Unit","title":"Computation_Unit","text":"Radiant.set_cross_sections(this::Radiant.Computation_Unit,cross_sections::Radiant.Cross_Sections)\nRadiant.set_geometry(this::Radiant.Computation_Unit,geometry::Radiant.Geometry)\nRadiant.set_solvers(this::Radiant.Computation_Unit,methods::Radiant.Solvers)\nRadiant.set_sources(this::Radiant.Computation_Unit,sources::Radiant.Fixed_Sources)\nRadiant.run(this::Radiant.Computation_Unit)\nRadiant.get_voxels_position(this::Radiant.Computation_Unit,axis::String)\nRadiant.get_energies(this::Radiant.Computation_Unit,particle::String)\nRadiant.get_flux(this::Radiant.Computation_Unit,particle::String)\nRadiant.get_energy_deposition(this::Radiant.Computation_Unit,type::String)\nRadiant.get_charge_deposition(this::Radiant.Computation_Unit,type::String)","category":"page"},{"location":"computation_unit/#Radiant.set_cross_sections-Tuple{Computation_Unit,Cross_Sections}","page":"Computation_Unit","title":"Radiant.set_cross_sections","text":"set_cross_sections(this::Computation_Unit,cross_sections::Cross_Sections)\n\nTo set the cross-sections library for transport calculations.\n\nInput Argument(s)\n\nthis::Computation_Unit: computation unit.\ncross_sections::Cross_Sections: cross-sections library.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> ... # Define cross-sections properties and generate multigroup cross-sections.\njulia> cu = Computation_Unit()\njulia> cu.set_cross_sections(cs)\n\n\n\n\n\n","category":"method"},{"location":"computation_unit/#Radiant.set_geometry-Tuple{Computation_Unit,Geometry}","page":"Computation_Unit","title":"Radiant.set_geometry","text":"set_geometry(this::Computation_Unit,geometry::Geometry)\n\nTo set the geometry for transport calculations.\n\nInput Argument(s)\n\nthis::Computation_Unit: computation unit.\ngeometry::Geometry: geometry.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> geo = Geometry()\njulia> ... # Define geometry and its properties\njulia> cu = Computation_Unit()\njulia> cu.set_geometry(geo)\n\n\n\n\n\n","category":"method"},{"location":"computation_unit/#Radiant.set_solvers-Tuple{Computation_Unit,Solvers}","page":"Computation_Unit","title":"Radiant.set_solvers","text":"setsolvers(this::ComputationUnit,solvers::Solvers)\n\nTo set the solvers for transport calculations.\n\nInput Argument(s)\n\nthis::Computation_Unit: computation unit.\nsolvers::Solvers: collection of solvers per particle.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> ms = Solvers()\njulia> ... # Define all the discretization solvers and their properties\njulia> cu = Computation_Unit()\njulia> cu.set_solvers(ms)\n\n\n\n\n\n","category":"method"},{"location":"computation_unit/#Radiant.set_sources-Tuple{Computation_Unit,Fixed_Sources}","page":"Computation_Unit","title":"Radiant.set_sources","text":"set_sources(this::Computation_Unit,sources::Fixed_Sources)\n\nTo set the fixed sources for transport calculations.\n\nInput Argument(s)\n\nthis::Computation_Unit: computation unit.\nsources::Fixed_Sources: collection of fixed sources.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> fs = Fixed_Sources()\njulia> ... # Define all the fixed sources and their properties\njulia> cu = Computation_Unit()\njulia> cu.set_sources(fs)\n\n\n\n\n\n","category":"method"},{"location":"computation_unit/#Radiant.run-Tuple{Computation_Unit}","page":"Computation_Unit","title":"Radiant.run","text":"run(this::Computation_Unit)\n\nTo lauch the transport calculations to solve the transport equation and obtain the flux solution.\n\nInput Argument(s)\n\nthis::Computation_Unit: computation unit.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cu = Computation_Unit()\njulia> ... # Define the cross-sections, geometry, fixed sources and discretization solvers\njulia> cu.run()\n\n\n\n\n\n","category":"method"},{"location":"computation_unit/#Radiant.get_voxels_position-Tuple{Computation_Unit,String}","page":"Computation_Unit","title":"Radiant.get_voxels_position","text":"get_voxels_position(this::Computation_Unit,axis::String)\n\nTo set the mid-point voxels position along the specified axis.\n\nInput Argument(s)\n\nthis::Computation_Unit: computation unit.\naxis::String: axis, which can takes the following values:\nboundary = \"x\": along x-axis\nboundary = \"y\": along y-axis\nboundary = \"z\": along z-axis\n\nOutput Argument(s)\n\nx::Vector{Float64}: mid-point voxels position along the specified axis.\n\nExamples\n\njulia> cu = Computation_Unit()\njulia> ... # Define computation unit and run it.\njulia> x = cu.get_voxels_position(\"x\")\n\n\n\n\n\n","category":"method"},{"location":"computation_unit/#Radiant.get_energies-Tuple{Computation_Unit,String}","page":"Computation_Unit","title":"Radiant.get_energies","text":"get_energies(this::Computation_Unit,particle::String)\n\nTo set the mid-point energy in each group for the specified particle.\n\nInput Argument(s)\n\nthis::Computation_Unit: computation unit.\nparticle::String: particle identifier, where each particle is either:\nparticle = \"photons\": photons.\nparticle = \"electrons\": electrons.\nparticle = \"positrons\": positrons.\n\nOutput Argument(s)\n\nE::Vector{Float64}: mid-point energy in each group for the specified particle.\n\nExamples\n\njulia> cu = Computation_Unit()\njulia> ... # Define computation unit and run it.\njulia> E = cu.get_voxels_position(\"electrons\")\n\n\n\n\n\n","category":"method"},{"location":"computation_unit/#Radiant.get_flux-Tuple{Computation_Unit,String}","page":"Computation_Unit","title":"Radiant.get_flux","text":"get_flux(this::Computation_Unit,particle::String)\n\nTo get the array containing the flux in each voxels and in each energy group for the specified particle.\n\nInput Argument(s)\n\nthis::Computation_Unit: computation unit.\nparticle::String: flux particle, which can takes the following values:\nparticle = \"photons\": photons charge deposition.\nparticle = \"electrons\": electrons charge deposition.\nparticle = \"positrons\": positrons charge deposition.\n\nOutput Argument(s)\n\nflux::Array{Float64}: flux array.\n\nExamples\n\njulia> cu = Computation_Unit()\njulia> ... # Define computation unit and run it.\njulia> flux = cu.get_flux(\"electrons\")\n\n\n\n\n\n","category":"method"},{"location":"computation_unit/#Radiant.get_energy_deposition-Tuple{Computation_Unit,String}","page":"Computation_Unit","title":"Radiant.get_energy_deposition","text":"get_energy_deposition(this::Computation_Unit,type::String)\n\nTo get the array containing the energy deposition in each voxels.\n\nInput Argument(s)\n\nthis::Computation_Unit: computation unit.\ntype::String: type of energy deposition, which can takes the following values:\ntype = \"total\": total energy deposition.\ntype = \"photons\": photons energy deposition.\ntype = \"electrons\": electrons energy deposition.\ntype = \"positrons\": positrons energy deposition.\n\nOutput Argument(s)\n\nenergy_deposition::Array{Float64}: energy deposition array.\n\nExamples\n\njulia> cu = Computation_Unit()\njulia> ... # Define computation unit and run it.\njulia> energy_deposition = cu.get_energy_deposition(\"total\")\n\n\n\n\n\n","category":"method"},{"location":"computation_unit/#Radiant.get_charge_deposition-Tuple{Computation_Unit,String}","page":"Computation_Unit","title":"Radiant.get_charge_deposition","text":"get_charge_deposition(this::Computation_Unit,type::String)\n\nTo get the array containing the charge deposition in each voxels.\n\nInput Argument(s)\n\nthis::Computation_Unit: computation unit.\ntype::String: type of charge deposition, which can takes the following values:\ntype = \"total\": total charge deposition.\ntype = \"photons\": photons charge deposition.\ntype = \"electrons\": electrons charge deposition.\ntype = \"positrons\": positrons charge deposition.\n\nOutput Argument(s)\n\ncharge_deposition::Array{Float64}: charge deposition array.\n\nExamples\n\njulia> cu = Computation_Unit()\njulia> ... # Define computation unit and run it.\njulia> charge_deposition = cu.get_charge_deposition(\"total\")\n\n\n\n\n\n","category":"method"},{"location":"quick_start/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"There are many ways to install RADIANT on your computer.","category":"page"},{"location":"quick_start/#Prerequisites","page":"Quick Start","title":"Prerequisites","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Before installing the Radiant package, ensure you have the following prerequisites:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Julia: Make sure Julia is installed on your system. You can download it from the official Julia website.","category":"page"},{"location":"quick_start/#Installation-from-Julia's-Package-Manager","page":"Quick Start","title":"Installation from Julia's Package Manager","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"This installation method is recommended for users of Radiant.","category":"page"},{"location":"quick_start/#Step-1:-Open-Julia-REPL","page":"Quick Start","title":"Step 1: Open Julia REPL","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"First, open Julia REPL interactive session by launching Julia from a terminal or command prompt typing","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"> julia","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"in it.","category":"page"},{"location":"quick_start/#Step-2:-Add-Radiant","page":"Quick Start","title":"Step 2: Add Radiant","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"To add your package from the Julia prompt, you can either use","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> using Pkg\njulia> Pkg.add(\"Radiant\")","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"or","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> ]\npkg> add Radiant","category":"page"},{"location":"quick_start/#Step-3:-Use-Radiant","page":"Quick Start","title":"Step 3: Use Radiant","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"After installation, you can start using the Radiant package by including it in your project by adding the","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"using Radiant","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"line in the project's code.","category":"page"},{"location":"quick_start/#Installation-from-Github-repository","page":"Quick Start","title":"Installation from Github repository","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"This installation method is recommended for developers of Radiant.","category":"page"},{"location":"quick_start/#Step-1:-Create-a-Local-Repository","page":"Quick Start","title":"Step 1: Create a Local Repository","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Create a new local repository, in which the development of new feature for Radiant will take place. Then, open the terminal or command prompt in that repository.","category":"page"},{"location":"quick_start/#Step-2:-Clone-the-Radiant-Github-Repository","page":"Quick Start","title":"Step 2: Clone the Radiant Github Repository","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Clone the Radiant Github repository to your local machine by running the following command in the terminal or command prompt:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"> git clone https://github.com/CBienvenue/Radiant.jl.git","category":"page"},{"location":"quick_start/#Step-3:-Install-the-Radiant-Package","page":"Quick Start","title":"Step 3: Install the Radiant Package","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"Open Julia REPL interactive session by launching Julia from a terminal or command prompt typing","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"> julia","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"in it. Create a new environment in the project directory using","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> ]\npkg> activate .","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"This creates a new environment in the current directory and switch to it. Your local package and its dependencies will be managed separately from the global environment. Then, navigate to the package directory by running the following command in the terminal or command prompt:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"julia> cd(\"Radiant.jl\")","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"In the Julia REPL, run","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"pkg> dev .\npkg> instantiate","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"This command tells Julia to develop the package located in the current directory. The dev command sets up the package for development, including adding it to your Julia environment. Then, the instantiate command is used to resolve and install any dependencies.","category":"page"},{"location":"quick_start/#Step-4:-Using-the-Local-Radiant-Package","page":"Quick Start","title":"Step 4: Using the Local Radiant Package","text":"","category":"section"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"After setting up the package, you can start using it by including it in your project with the using keyword:","category":"page"},{"location":"quick_start/","page":"Quick Start","title":"Quick Start","text":"using Radiant","category":"page"},{"location":"material/#Structure","page":"Material","title":"Structure","text":"","category":"section"},{"location":"material/","page":"Material","title":"Material","text":"Radiant.Radiant.Material","category":"page"},{"location":"material/#Radiant.Material","page":"Material","title":"Radiant.Material","text":"Material\n\nStructure used to define a material and its properties.\n\nMandatory field(s)\n\nname::String: name (or identifier) of the Material structure.\ndensity::Float64: density [in g/cm³].\nelements::Vector{String}: vector of the element in the composition of the material.\nweight_fractions::Vector{Float64}: vector of the weight fraction for each element in the composition of the material.\n\nOptional field(s) - with default values\n\nstate_of_matter::String = \"solid\": state of the matter.\n\n\n\n\n\n","category":"type"},{"location":"material/#Methods","page":"Material","title":"Methods","text":"","category":"section"},{"location":"material/","page":"Material","title":"Material","text":"Radiant.set_name(this::Radiant.Material,name::String)\nRadiant.set_density(this::Radiant.Material,density::Real)\nRadiant.set_state_of_matter(this::Radiant.Material,state_of_matter::String)\nRadiant.add_element(this::Radiant.Material,symbol::String,weight_fraction::Real)","category":"page"},{"location":"material/#Radiant.set_density-Tuple{Material,Real}","page":"Material","title":"Radiant.set_density","text":"set_density(this::Material,density::Real)\n\nTo set the density of the material.\n\nInput Argument(s)\n\nthis::Material: material.\ndensity::Real: density [in g/cm³].\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> mat.set_density(19.3)\n\n\n\n\n\n","category":"method"},{"location":"material/#Radiant.set_state_of_matter-Tuple{Material,String}","page":"Material","title":"Radiant.set_state_of_matter","text":"set_state_of_matter(this::Material,state_of_matter::String)\n\nTo set the state of the matter (solid or liquid or gaz).\n\nInput Argument(s)\n\nthis::Material: material.\nstate_of_matter::String: state of matter, which value is given by \"solid\", \"liquid\" or \"gaz\".\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> mat.set_state_of_matter(\"liquid\")\n\n\n\n\n\n","category":"method"},{"location":"material/#Radiant.add_element-Tuple{Material,String,Real}","page":"Material","title":"Radiant.add_element","text":"add_element(this::Material,symbol::String,weight_fraction::Real=1)\n\nTo add an element which is part of the composition of the material.\n\nInput Argument(s)\n\nthis::Material: material.\nsymbol::String: element symbol, with value such as \"H\", \"He\", etc.\nweight_fraction::Real: weight fraction of the element in the material (between 0 and 1).\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> water.add_element(\"H\",0.1111)\njulia> water.add_element(\"O\",0.8889)\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Structure","page":"Solvers","title":"Structure","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Radiant.Solvers","category":"page"},{"location":"solvers/#Radiant.Solvers","page":"Solvers","title":"Radiant.Solvers","text":"Solvers\n\nStructure used to define the collection of discretization methods for transport calculations associated with each of the particle and additionnal coupled transport informations.\n\nMandatory field(s)\n\nmethods_list::Vector{Discrete_Ordinates}: list of the particle methods\nnumber_of_generations::Int64: number of particle generations to transport.\n\nOptional field(s) - with default values\n\nN/A\n\n\n\n\n\n","category":"type"},{"location":"solvers/#Methods","page":"Solvers","title":"Methods","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Radiant.add_solver(this::Radiant.Solvers,method::Radiant.Discrete_Ordinates)\nRadiant.set_number_of_generations(this::Radiant.Solvers,number_of_generations::Int64)","category":"page"},{"location":"solvers/#Radiant.add_solver-Tuple{Solvers,Discrete_Ordinates}","page":"Solvers","title":"Radiant.add_solver","text":"add_solver(this::Solvers,method::Discrete_Ordinates)\n\nTo add a particle and is associated methods to the Solvers structure.\n\nInput Argument(s)\n\nthis::Solvers: collection of discretization method.\nmethod::Discrete_Ordinates: discretization method.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> ... # Define the methods properties\njulia> ms = Solvers()\njulia> ms.add_solver(m)\n\n\n\n\n\n","category":"method"},{"location":"solvers/#Radiant.set_number_of_generations-Tuple{Solvers,Int64}","page":"Solvers","title":"Radiant.set_number_of_generations","text":"set_number_of_generations(this::Solvers,number_of_generations::Int64)\n\nTo set the number of particle generation to transport during calculations\n\nInput Argument(s)\n\nthis::Solvers: collection of discretization method.\nnumber_of_generations::Int64: number of particle generation to transport during calculations.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> ms = Solvers()\njulia> ms.set_number_of_generations(2)\n\n\n\n\n\n","category":"method"},{"location":"compton/#Structure","page":"Compton","title":"Structure","text":"","category":"section"},{"location":"compton/","page":"Compton","title":"Compton","text":"Radiant.Compton","category":"page"},{"location":"compton/#Radiant.Compton","page":"Compton","title":"Radiant.Compton","text":"Compton\n\nStructure used to define parameters for production of multigroup Compton cross-sections.\n\nMandatory field(s)\n\nN/A\n\nOptional field(s) - with default values\n\ninteraction_types::Dict{Tuple{String,String},Vector{String}} = Dict((\"photons\",\"photons\") => [\"S\"],(\"photons\",\"electrons\") => [\"P\"]): Dictionary of the interaction processes types, of the form (incident particle,outgoing particle) => associated list of interaction type, which values correspond:\n(\"photons\",\"photons\") => [\"S\"]: scattering of incident photon following Compton interaction.\n(\"photons\",\"electrons\") => [\"P\"]: produced electron following Compton interaction.\n\n\n\n\n\n","category":"type"},{"location":"compton/#Methods","page":"Compton","title":"Methods","text":"","category":"section"},{"location":"compton/","page":"Compton","title":"Compton","text":"Radiant.set_is_waller_hartree_factor(this::Radiant.Compton,is_waller_hartree_factor::Bool)\nRadiant.set_interaction_types(this::Radiant.Compton,interaction_types::Dict{Tuple{String,String},Vector{String}})","category":"page"},{"location":"compton/#Radiant.set_interaction_types-Tuple{Compton,Dict{Tuple{String,String},Array{String,1}}}","page":"Compton","title":"Radiant.set_interaction_types","text":"set_interaction_types(this::Compton,interaction_types::Dict{Tuple{String,String},Vector{String}})\n\nTo define the interaction types for Compton processes.\n\nInput Argument(s)\n\nthis::Compton: compton structure.\ninteraction_types::Dict{Tuple{String,String},Vector{String}}: Dictionary of the interaction processes types, of the form (incident particle,outgoing particle) => associated list of interaction type, which can be:\n(\"photons\",\"photons\")   => [\"S\"] : scattering of incident photon following Compton interaction.\n(\"photons\",\"electrons\") => [\"P\"] : produced electron following Compton interaction.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> compton = Compton()\njulia> compton.set_interaction_types( Dict((\"photons\",\"photons\") => [\"S\"]) ) # Electron are absorbed following Compton interaction.\n\n\n\n\n\n","category":"method"},{"location":"elastic_leptons/#Structure","page":"Elastic_Leptons","title":"Structure","text":"","category":"section"},{"location":"elastic_leptons/","page":"Elastic_Leptons","title":"Elastic_Leptons","text":"Radiant.Elastic_Leptons","category":"page"},{"location":"elastic_leptons/#Radiant.Elastic_Leptons","page":"Elastic_Leptons","title":"Radiant.Elastic_Leptons","text":"Elastic_Leptons\n\nStructure used to define parameters for production of multigroup elastic cross-sections for leptons.\n\nMandatory field(s)\n\nN/A\n\nOptional field(s) - with default values\n\ninteraction_types::Dict{Tuple{String,String},Vector{String}} = Dict((\"electrons\",\"electrons\") => [\"S\"],(\"positrons\",\"positrons\") => [\"S\"]): Dictionary of the interaction processes types, of the form (incident particle,outgoing particle) => associated list of interaction type, which values correspond:\n(\"electrons\",\"electrons\") => [\"S\"]: elastic interaction of electrons.\n(\"positrons\",\"positrons\") => [\"S\"]: elastic interaction of positrons.\n\n\n\n\n\n","category":"type"},{"location":"elastic_leptons/#Methods","page":"Elastic_Leptons","title":"Methods","text":"","category":"section"},{"location":"elastic_leptons/","page":"Elastic_Leptons","title":"Elastic_Leptons","text":"Radiant.set_model(this::Radiant.Elastic_Leptons,model::String)\nRadiant.set_transport_correction(this::Radiant.Elastic_Leptons,is_ETC::Bool)\nRadiant.set_angular_fokker_planck(this::Radiant.Elastic_Leptons,is_AFP::Bool)\nRadiant.set_kawrakow_correction(this::Radiant.Elastic_Leptons,is_kawrakow_correction::Bool,subshell_dependant_inelastic::Bool=true)\nRadiant.set_interaction_types(this::Radiant.Elastic_Leptons,interaction_types::Dict{Tuple{String,String},Vector{String}})","category":"page"},{"location":"elastic_leptons/#Radiant.set_model-Tuple{Elastic_Leptons,String}","page":"Elastic_Leptons","title":"Radiant.set_model","text":"set_model(this::Elastic_Leptons,model::String,is_KC::Bool=true)\n\nTo define the elastic scattering model.\n\nInput Argument(s)\n\nthis::Elastic_Leptons: elastic leptons structure.\nmodel::String: model of elastic scattering:\nrutherford: screened Rutherford cross-sections.\nmott: screened Mott cross-sections.\nis_KC::Bool: Apply Karakow's Correction (true) or not (false).\nis_SC::Bool: Apply Seltzer's Correction (true) or not (false).\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> elastic_leptons = Elastic_Leptons()\njulia> elastic_leptons.set_model(\"rutherford\")\n\n\n\n\n\n","category":"method"},{"location":"elastic_leptons/#Radiant.set_transport_correction-Tuple{Elastic_Leptons,Bool}","page":"Elastic_Leptons","title":"Radiant.set_transport_correction","text":"set_transport_correction(this::Elastic_Leptons,is_ETC::Bool)\n\nEnable or not extended transport correcton.\n\nInput Argument(s)\n\nthis::Elastic_Leptons: elastic leptons structure.\nis_ETC::Bool: Enable (true) or not (false) extended transport correcton.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> elastic_leptons = Elastic_Leptons()\njulia> elastic_leptons.is_ETC(false)\n\n\n\n\n\n","category":"method"},{"location":"elastic_leptons/#Radiant.set_interaction_types-Tuple{Elastic_Leptons,Dict{Tuple{String,String},Array{String,1}}}","page":"Elastic_Leptons","title":"Radiant.set_interaction_types","text":"set_interaction_types(this::Elastic_Leptons,interaction_types::Dict{Tuple{String,String},Vector{String}})\n\nTo define the interaction types for Elastic_Leptons processes.\n\nInput Argument(s)\n\nthis::Elastic_Leptons: elastic leptons structure.\ninteraction_types::Dict{Tuple{String,String},Vector{String}}: Dictionary of the interaction processes types, of the form (incident particle,outgoing particle) => associated list of interaction type, which can be:\n(\"electrons\",\"electrons\") => [\"S\"]: elastic interaction of electrons.\n(\"positrons\",\"positrons\") => [\"S\"]: elastic interaction of positrons.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> elastic_leptons = Elastic_Leptons()\njulia> elastic_leptons.set_interaction_types( Dict((\"positrons\",\"positrons\") => [\"S\"]) ) # Elastic only for positrons\n\n\n\n\n\n","category":"method"},{"location":"example_cross_sections/#Production-of-cross-sections","page":"Production of cross-sections","title":"Production of cross-sections","text":"","category":"section"},{"location":"example_cross_sections/","page":"Production of cross-sections","title":"Production of cross-sections","text":"RADIANT can produce multigroup cross-sections for photons, electrons and positrons.","category":"page"},{"location":"example_cross_sections/#Example-1:-Production-of-coupled-photons-electrons-positrons-cross-sections-in-water","page":"Production of cross-sections","title":"Example 1: Production of coupled photons-electrons-positrons cross-sections in water","text":"","category":"section"},{"location":"example_cross_sections/","page":"Production of cross-sections","title":"Production of cross-sections","text":"\n# Define the medium (water)\nwater = Material()\nwater.set_name(\"water\")\nwater.set_density(1.0)\nwater.set_state_of_matter(\"liquid\")\nwater.add_element(\"H\",0.1111)\nwater.add_element(\"O\",0.8889)\n\n# Define the cross-sections parameters\ncs = Cross_Sections()\ncs.set_source(\"RADIANT\")\ncs.set_materials([water]) \ncs.set_particles([\"photons\",\"electrons\",\"positrons\"])\ncs.set_energy(10)\ncs.set_cutoff(0.001)\ncs.set_number_of_groups([80,80,80])\ncs.set_group_structure([\"log\",\"log\",\"log\"])\ncs.set_solvers([\"BTE\",\"BFP\",\"BFP\"])\ninteraction_list = [\n    Elastic_Leptons(),\n    Inelastic_Leptons(),\n    Bremsstrahlung(),\n    Annihilation(),\n    Auger(),\n    Fluorescence(),\n    Pair_Production(),\n    Photoelectric(),\n    Rayleigh(),\n    Compton()\n]\ncs.set_interactions(interaction_list)\ncs.set_legendre_order(7)\ncs.build()\n\n# Save cross-sections in a FMAC-M file\ncs.write(\"(path here)/fmac_m.txt\")\n","category":"page"},{"location":"geometry/#Structure","page":"Geometry","title":"Structure","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Radiant.Geometry","category":"page"},{"location":"geometry/#Radiant.Geometry","page":"Geometry","title":"Radiant.Geometry","text":"Geometry\n\nStructure used to define the geometry properties of the medium for transport calculations.\n\nMandatory field(s)\n\nname::String: name (or identifier) of the Geometry structure.\ndimension::Int64: dimension of the geometry.\nmaterial_per_region::Array{Material}: multidimensional array of the material per regions.\nboundary_conditions::Dict{String,Int64}: boundary conditions along each axis.\nnumber_of_regions::Dict{String,Int64}: number of regions along each axis.\nvoxels_per_region::Dict{String,Vector{Int64}}: number of voxels inside each regions along each axis.\nregion_boundaries::Dict{String,Vector{Float64}}: boundaries of each regions along each axis.\n\nOptional field(s) - with default values\n\ntype::String=\"cartesian\": type of geometry.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#Methods","page":"Geometry","title":"Methods","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Radiant.set_type(this::Radiant.Geometry,type::String)\nRadiant.set_dimension(this::Radiant.Geometry,dimension::Int64)\nRadiant.set_boundary_conditions(this::Radiant.Geometry,boundary::String,boundary_condition::String)\nRadiant.set_number_of_regions(this::Radiant.Geometry,axis::String,number_of_regions::Int64)\nRadiant.set_voxels_per_region(this::Radiant.Geometry,axis::String,voxels_per_region::Vector{Int64})\nRadiant.set_region_boundaries(this::Radiant.Geometry,axis::String,region_boundaries::Vector{Float64})\n\nRadiant.set_material_per_region(this::Radiant.Geometry,material_per_region::Array{Radiant.Material})\nRadiant.build(this::Radiant.Geometry,cs::Radiant.Cross_Sections)","category":"page"},{"location":"geometry/#Radiant.set_type-Tuple{Geometry,String}","page":"Geometry","title":"Radiant.set_type","text":"set_type(this::Geometry,type::String)\n\nTo set the type of geometry.\n\nInput Argument(s)\n\nthis::Geometry: geometry.\ntype::String: type of geometry, which can takes the following value:   -type = \"cartesian\": Cartesian geometry.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> geo = Geometry()\njulia> geo.set_type(\"cartesian\")\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Radiant.set_dimension-Tuple{Geometry,Int64}","page":"Geometry","title":"Radiant.set_dimension","text":"set_dimension(this::Geometry,dimension::Int64)\n\nTo set the dimension of geometry.\n\nInput Argument(s)\n\nthis::Geometry: geometry.\ndimension::Int64: dimension of the geometry, which can be either 1, 2 or 3.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> geo = Geometry()\njulia> geo.set_dimension(2) # For 2D geometry\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Radiant.set_boundary_conditions-Tuple{Geometry,String,String}","page":"Geometry","title":"Radiant.set_boundary_conditions","text":"set_boundary_conditions(this::Geometry,boundary::String,boundary_condition::String)\n\nTo set the boundary conditions at the specified boundary.\n\nInput Argument(s)\n\nthis::Geometry: geometry.\nboundary::String: boundary for which the boundary condition is applied, which can takes the following value:\nboundary = \"x-\": the lower bound along x-axis\nboundary = \"x+\": the upper bound along x-axis\nboundary = \"y-\": the lower bound along y-axis\nboundary = \"y+\": the upper bound along y-axis\nboundary = \"z-\": the lower bound along z-axis\nboundary = \"z+\": the upper bound along z-axis\nboundary_condition::String: boundary conditions, which can takes the following value:   -boundary = \"void\": void boundary conditions.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> geo = Geometry()\njulia> geo.set_boundary_conditions(\"x-\",\"void\")\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Radiant.set_number_of_regions-Tuple{Geometry,String,Int64}","page":"Geometry","title":"Radiant.set_number_of_regions","text":"set_number_of_regions(this::Geometry,axis::String,number_of_regions::Int64)\n\nTo set the number of regions along a specified axis.\n\nInput Argument(s)\n\nthis::Geometry: geometry.\naxis::String: axis along which the number of regions is specified, which can takes the following values:\nboundary = \"x\": along x-axis\nboundary = \"y\": along y-axis\nboundary = \"z\": along z-axis\nnumber_of_regions::Int64: number of regions.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> geo = Geometry()\njulia> geo.set_number_of_regions(\"x\",3)\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Radiant.set_voxels_per_region-Tuple{Geometry,String,Array{Int64,1}}","page":"Geometry","title":"Radiant.set_voxels_per_region","text":"set_voxels_per_region(this::Geometry,axis::String,voxels_per_region::Vector{Int64})\n\nTo set the number of voxels for each regions along a specified axis.\n\nInput Argument(s)\n\nthis::Geometry: geometry.\naxis::String: axis along which the number of regions is specified, which can takes the following values:\nboundary = \"x\": along x-axis\nboundary = \"y\": along y-axis\nboundary = \"z\": along z-axis\nvoxels_per_region::Vector{Int64}: vector with the number of voxels for each regions along the specified axis.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> geo = Geometry()\njulia> geo.set_number_of_regions(\"x\",3)\njulia> geo.set_voxels_per_region(\"x\",[10,5,2])\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Radiant.set_region_boundaries-Tuple{Geometry,String,Array{Float64,1}}","page":"Geometry","title":"Radiant.set_region_boundaries","text":"set_region_boundaries(this::Geometry,axis::String,region_boundaries::Vector{Float64})\n\nTo set the boundaries of each regions along a specified axis.\n\nInput Argument(s)\n\nthis::Geometry: geometry.\naxis::String: axis along which the number of regions is specified, which can takes the following values:\nboundary = \"x\": along x-axis\nboundary = \"y\": along y-axis\nboundary = \"z\": along z-axis\nregion_boundaries::Vector{Float64}: vector with the regions boundaries along the specified axis in ascending order.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> geo = Geometry()\njulia> geo.set_number_of_regions(\"x\",3)\njulia> geo.set_voxels_per_region(\"x\",[10,5,2])\njulia> geo.set_voxels_per_region(\"x\",[0.0 0.3 0.5 1.0])\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Radiant.set_material_per_region-Tuple{Geometry,Array{Material,N} where N}","page":"Geometry","title":"Radiant.set_material_per_region","text":"set_material_per_region(this::Geometry,material_per_region::Array{Material})\n\nTo set the material in each regions of the geometry.\n\nInput Argument(s)\n\nthis::Geometry: geometry.\nmaterial_per_region::Array{Material}: array containing the material for each regions. Its size should fit the number of regions per axis.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\n# Define material\njulia> mat1 = Material(); mat2 = Material()\njulia> ... # Define the material properties\n\n# 1D geometry case\njulia> geo1D = Geometry()\njulia> geo1D.set_type(\"cartesian\")\njulia> geo1D.set_dimension(1)\njulia> geo1D.set_number_of_regions(\"x\",3)\njulia> geo1D.set_material_per_region([mat1 mat2 mat1])\n\n# 2D geometry case\njulia> geo1D = Geometry()\njulia> geo1D.set_type(\"cartesian\")\njulia> geo1D.set_dimension(2)\njulia> geo1D.set_number_of_regions(\"x\",2)\njulia> geo1D.set_number_of_regions(\"y\",3)\njulia> geo1D.set_material_per_region([mat1 mat2 mat1 ; mat2 mat1 mat2])\n\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Radiant.build-Tuple{Geometry,Cross_Sections}","page":"Geometry","title":"Radiant.build","text":"build(this::Geometry,cs::Cross_Sections)\n\nTo build the geometry structure.\n\nInput Argument(s)\n\nthis::Geometry: geometry.\ncs::Cross_Sections: cross-sections library.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> ... # Defining the cross-sections library properties\njulia> cs.build()\njulia> geo = Geometry()\njulia> ... # Defining the geometry properties\njulia> geo.build(cs)\n\n\n\n\n\n","category":"method"},{"location":"bremsstrahlung/#Structure","page":"Bremsstrahlung","title":"Structure","text":"","category":"section"},{"location":"bremsstrahlung/","page":"Bremsstrahlung","title":"Bremsstrahlung","text":"Radiant.Bremsstrahlung","category":"page"},{"location":"bremsstrahlung/#Radiant.Bremsstrahlung","page":"Bremsstrahlung","title":"Radiant.Bremsstrahlung","text":"Bremsstrahlung\n\nStructure used to define parameters for production of multigroup bremsstrahlung cross-sections.\n\nMandatory field(s)\n\nN/A\n\nOptional field(s) - with default values\n\ninteraction_types::Dict{Tuple{String,String},Vector{String}} = Dict((\"electrons\",\"electrons\") => [\"S\"],(\"electrons\",\"photons\") => [\"P\"],(\"positrons\",\"positrons\") => [\"S\"],(\"positrons\",\"photons\") => [\"P\"]): Dictionary of the interaction processes types, of the form (incident particle,outgoing particle) => associated list of interaction type, which values correspond:\n(\"electrons\",\"electrons\") => [\"S\"]: scattering of incident electron following Bremsstrahlung interaction.\n(\"electrons\",\"photons\") => [\"P\"]: produced photon following Bremsstrahlung interaction by incident electron.\n(\"positrons\",\"positrons\") => [\"S\"]: scattering of incident positron following Bremsstrahlung interaction.\n(\"positrons\",\"photons\") => [\"P\"]: produced photon following Bremsstrahlung interaction by incident positron.\nangular_scattering_type::String=modified_dipole: type of angular scattering, which can takes the following values:\nangular_scattering_type = modified_dipole: modified dipôle distribution, based on Poskus (2019) shape functions.\nangular_scattering_type = sommerfield: Sommerfield distribution.\n\n\n\n\n\n","category":"type"},{"location":"bremsstrahlung/#Methods","page":"Bremsstrahlung","title":"Methods","text":"","category":"section"},{"location":"bremsstrahlung/","page":"Bremsstrahlung","title":"Bremsstrahlung","text":"Radiant.set_interaction_types(this::Radiant.Bremsstrahlung,interaction_types::Dict{Tuple{String,String},Vector{String}})\nRadiant.set_angular_scattering_type(this::Radiant.Bremsstrahlung,angular_scattering_type::String)","category":"page"},{"location":"bremsstrahlung/#Radiant.set_interaction_types-Tuple{Bremsstrahlung,Dict{Tuple{String,String},Array{String,1}}}","page":"Bremsstrahlung","title":"Radiant.set_interaction_types","text":"set_interaction_types(this::Bremsstrahlung,interaction_types::Dict{Tuple{String,String},Vector{String}})\n\nTo define the interaction types for bremsstrahlung processes.\n\nInput Argument(s)\n\nthis::Bremsstrahlung: bremsstrahlung structure.\ninteraction_types::Dict{Tuple{String,String},Vector{String}}: Dictionary of the interaction processes types, of the form (incident particle,outgoing particle) => associated list of interaction type, which can be:\n(\"electrons\",\"electrons\") => [\"S\"]: scattering of incident electron following Bremsstrahlung interaction.\n(\"electrons\",\"photons\") => [\"P\"]: produced photon following Bremsstrahlung interaction by incident electron.\n(\"positrons\",\"positrons\") => [\"S\"]: scattering of incident positron following Bremsstrahlung interaction.\n(\"positrons\",\"photons\") => [\"P\"]: produced photon following Bremsstrahlung interaction by incident positron.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> bremsstrahlung = Bremsstrahlung()\njulia> bremsstrahlung.set_interaction_types( Dict((\"electrons\",\"electrons\") => [\"S\"]) ) # Only electron scattering, with photon absorption.\n\n\n\n\n\n","category":"method"},{"location":"bremsstrahlung/#Radiant.set_angular_scattering_type-Tuple{Bremsstrahlung,String}","page":"Bremsstrahlung","title":"Radiant.set_angular_scattering_type","text":"set_angular_scattering_type(this::Bremsstrahlung,angular_scattering_type::String)\n\nTo define the bremsstrahlung photons angular distribution.\n\nInput Argument(s)\n\nthis::Bremsstrahlung: bremsstrahlung structure.\nangular_scattering_type::String: angular scattering type.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> bremsstrahlung = Bremsstrahlung()\njulia> bremsstrahlung.set_angular_scattering_type(\"sommerfield\")\n\n\n\n\n\n","category":"method"},{"location":"annihilation/#Structure","page":"Annihilation","title":"Structure","text":"","category":"section"},{"location":"annihilation/","page":"Annihilation","title":"Annihilation","text":"Radiant.Annihilation","category":"page"},{"location":"annihilation/#Radiant.Annihilation","page":"Annihilation","title":"Radiant.Annihilation","text":"Annihilation\n\nStructure used to define parameters for production of multigroup annihilation cross-sections.\n\nMandatory field(s)\n\nN/A\n\nOptional field(s) - with default values\n\ninteraction_types::Dict{Tuple{String,String},Vector{String}} = Dict((\"positrons\",\"positrons\") => [\"A\"],(\"positrons\",\"photons\") => [\"P₋\",\"P₊\",\"P_inel\",\"P_brems\"],(\"photons\",\"photons\") => [\"P_pp\"]): Dictionary of the interaction processes types, of the form (incident particle,outgoing particle) => associated list of interaction type, which values correspond:\n(\"positrons\",\"positrons\") => [\"A\"]: absorption of the incoming positron.\n(\"positrons\",\"photons\") => [\"P₋\"]: production of the lowest energy photon following annihilation.\n(\"positrons\",\"photons\") => [\"P₊\"]: production of the highest energy photon following annihilation.\n(\"positrons\",\"photons\") => [\"P_inel\"]: production of annihilation photons from inelastic collisional positrons absorption following scattering under the cutoff energy.\n(\"positrons\",\"photons\") => [\"P_brems\"]: production of annihilation photons from Bremsstrahlung positrons absorption following scattering under the cutoff energy.\n(\"photons\",\"photons\") => [\"P_pp\"]: production of annihilation photons from absorption of positrons following their production under the cutoff energy.\n\n\n\n\n\n","category":"type"},{"location":"annihilation/#Methods","page":"Annihilation","title":"Methods","text":"","category":"section"},{"location":"annihilation/","page":"Annihilation","title":"Annihilation","text":"Radiant.set_interaction_types(this::Radiant.Annihilation,interaction_types::Dict{Tuple{String,String},Vector{String}})","category":"page"},{"location":"annihilation/#Radiant.set_interaction_types-Tuple{Annihilation,Dict{Tuple{String,String},Array{String,1}}}","page":"Annihilation","title":"Radiant.set_interaction_types","text":"set_interaction_types(this::Annihilation,interaction_types::Dict{Tuple{String,String},Vector{String}})\n\nTo define the interaction types for annihilation processes.\n\nInput Argument(s)\n\nthis::Annihilation: annihilation structure.\ninteraction_types::Dict{Tuple{String,String},Vector{String}}: Dictionary of the interaction processes types, of the form (incident particle,outgoing particle) => associated list of interaction type, which can be:\n(\"positrons\",\"positrons\") => [\"A\"]: absorption of the incoming positron.\n(\"positrons\",\"photons\") => [\"P₋\"]: production of the lowest energy photon following annihilation.\n(\"positrons\",\"photons\") => [\"P₊\"]: production of the highest energy photon following annihilation.\n(\"positrons\",\"photons\") => [\"P_inel\"]: production of annihilation photons from inelastic collisional positrons absorption following scattering under the cutoff energy.\n(\"positrons\",\"photons\") => [\"P_brems\"]: production of annihilation photons from Bremsstrahlung positrons absorption following scattering under the cutoff energy.\n(\"photons\",\"photons\") => [\"P_pp\"]: production of annihilation photons from absorption of positrons following their production under the cutoff energy.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> annihilation = Annihilation()\njulia> annihilation.set_interaction_types( Dict((\"positrons\",\"positrons\") => [\"A\"]) ) # Annihilation is set to be only absorption of positrons without any production of photons\n\n\n\n\n\n","category":"method"},{"location":"photoelectric/#Structure","page":"Photoelectric","title":"Structure","text":"","category":"section"},{"location":"photoelectric/","page":"Photoelectric","title":"Photoelectric","text":"Radiant.Photoelectric","category":"page"},{"location":"photoelectric/#Radiant.Photoelectric","page":"Photoelectric","title":"Radiant.Photoelectric","text":"Photoelectric\n\nStructure used to define parameters for production of multigroup photoelectric cross-sections.\n\nMandatory field(s)\n\nN/A\n\nOptional field(s) - with default values\n\ninteraction_types::Dict{Tuple{String,String},Vector{String}} = Dict((\"photons\",\"photons\") => [\"A\"],(\"photons\",\"electrons\") => [\"P\"]): Dictionary of the interaction processes types, of the form (incident particle,outgoing particle) => associated list of interaction type, which values correspond:\n(\"photons\",\"photons\") => [\"A\"]: absorption of incoming photon.\n(\"photons\",\"electrons\") => [\"P\"]: produced photo-electron.\n\n\n\n\n\n","category":"type"},{"location":"photoelectric/#Methods","page":"Photoelectric","title":"Methods","text":"","category":"section"},{"location":"photoelectric/","page":"Photoelectric","title":"Photoelectric","text":"Radiant.set_model(this::Radiant.Photoelectric,model::String)\nRadiant.set_interaction_types(this::Radiant.Photoelectric,interaction_types::Dict{Tuple{String,String},Vector{String}})","category":"page"},{"location":"photoelectric/#Radiant.set_model-Tuple{Photoelectric,String}","page":"Photoelectric","title":"Radiant.set_model","text":"set_model(this::Photoelectric,model::String)\n\nTo define the photoelectric model.\n\nInput Argument(s)\n\nthis::Photoelectric: photoelectric structure.\nmodel::String: cross-section model:\njendl5: evaluated subshell-dependent cross-sections.\nbiggs_lighthill: Biggs and Lighthill cross-sections.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> photoelectric = Photoelectric()\njulia> photoelectric.set_model(\"biggs_lighthill\")\n\n\n\n\n\n","category":"method"},{"location":"photoelectric/#Radiant.set_interaction_types-Tuple{Photoelectric,Dict{Tuple{String,String},Array{String,1}}}","page":"Photoelectric","title":"Radiant.set_interaction_types","text":"set_interaction_types(this::Photoelectric,interaction_types::Dict{Tuple{String,String},Vector{String}})\n\nTo define the interaction types for photoelectric processes.\n\nInput Argument(s)\n\nthis::Photoelectric: photoelectric structure.\ninteraction_types::Dict{Tuple{String,String},Vector{String}}: Dictionary of the interaction processes types, of the form (incident particle,outgoing particle) => associated list of interaction type, which can be:\n(\"photons\",\"photons\") => [\"A\"]: absorption of incoming photon.\n(\"photons\",\"electrons\") => [\"P\"]: produced photo-electron.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> photoelectric = Photoelectric()\njulia> photoelectric.set_interaction_types( Dict((\"photons\",\"photons\") => [\"A\"],(\"photons\",\"electrons\") => [\"P\"]) ) # Full photoelectric phenomenon (default case).\n\n\n\n\n\n","category":"method"},{"location":"volume_source/#Structure","page":"Volume_Source","title":"Structure","text":"","category":"section"},{"location":"volume_source/","page":"Volume_Source","title":"Volume_Source","text":"Radiant.Volume_Source","category":"page"},{"location":"volume_source/#Radiant.Volume_Source","page":"Volume_Source","title":"Radiant.Volume_Source","text":"Volume_Source\n\nStructure used to define an isotropic volume source and its properties.\n\nMandatory field(s)\n\nname::String: name (or identifier) of the Volume_Source structure.\nparticle::String: type of particle emitted.\nenergy_group::Int64: energy group index in which the particle are emitted.\nboundaries::Vector{Float64}: boundaries of the source along each axis [in cm].\n\nOptional field(s) - with default values\n\nintensity::Float64=1.0: intensity [# particles/cmᴺ, where N is the geometry dimension].\n\n\n\n\n\n","category":"type"},{"location":"volume_source/#Methods","page":"Volume_Source","title":"Methods","text":"","category":"section"},{"location":"volume_source/","page":"Volume_Source","title":"Volume_Source","text":"Radiant.set_particle(this::Radiant.Volume_Source,particle::String)\nRadiant.set_intensity(this::Radiant.Volume_Source,intensity::Real)\nRadiant.set_energy_group(this::Radiant.Volume_Source,energy_group::Int64)\nRadiant.set_boundaries(this::Radiant.Volume_Source,axis::String,boundaries::Vector{Float64})","category":"page"},{"location":"volume_source/#Radiant.set_particle-Tuple{Volume_Source,String}","page":"Volume_Source","title":"Radiant.set_particle","text":"set_particle(this::Volume_Source,particle::String)\n\nTo define the source particle.\n\nInput Argument(s)\n\nthis::Volume_Source: volume source.\nparticle::String: type of particle, which can takes the following values:\nparticle = \"photons\": photons.\nparticle = \"electrons\": electrons.\nparticle = \"positrons\": positrons.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> vs = Volume_Source()\njulia> vs.set_particle(\"electrons\")\n\n\n\n\n\n","category":"method"},{"location":"volume_source/#Radiant.set_intensity-Tuple{Volume_Source,Real}","page":"Volume_Source","title":"Radiant.set_intensity","text":"set_intensity(this::Volume_Source,intensity::Real)\n\nTo define the intensity of the source.\n\nInput Argument(s)\n\nthis::Volume_Source: volume source.\nintensity::Float64: intensity [# particles/cmᴺ, where N is the geometry dimension]\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> vs = Volume_Source()\njulia> vs.set_intensity(100)\n\n\n\n\n\n","category":"method"},{"location":"volume_source/#Radiant.set_energy_group-Tuple{Volume_Source,Int64}","page":"Volume_Source","title":"Radiant.set_energy_group","text":"set_energy_group(this::Volume_Source,energy_group::Int64)\n\nTo define the energy of the source by setting the energy group in which they are produced.\n\nInput Argument(s)\n\nthis::Volume_Source: volume source.\nenergy_group::Int64: energy group index.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> vs = Volume_Source()\njulia> vs.set_energy_group(1)\n\n\n\n\n\n","category":"method"},{"location":"volume_source/#Radiant.set_boundaries-Tuple{Volume_Source,String,Array{Float64,1}}","page":"Volume_Source","title":"Radiant.set_boundaries","text":"set_boundaries(this::Volume_Source,axis::String,boundaries::Vector{Float64})\n\nTo define the boundaries of the source along the specified axis.\n\nInput Argument(s)\n\nthis::Volume_Source: volume source.\naxis::String: axis along which the boundaries are defined.\nboundaries::Vector{Float64}: boundaries of the source in accending order [in cm]\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> vs = Volume_Source()\njulia> vs.set_boundaries(\"x\",[1.0,3.0])\n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Structure","page":"Discrete_Ordinates","title":"Structure","text":"","category":"section"},{"location":"discrete_ordinates/","page":"Discrete_Ordinates","title":"Discrete_Ordinates","text":"Radiant.Discrete_Ordinates","category":"page"},{"location":"discrete_ordinates/#Radiant.Discrete_Ordinates","page":"Discrete_Ordinates","title":"Radiant.Discrete_Ordinates","text":"Discrete_Ordinates\n\nStructure used to define the discretization method associated with the transport of a particle.\n\nMandatory field(s)\n\nname::String: name (or identifier) of the Discrete_Ordinates structure.\nparticle::String: particle for which the discretization methods is defined\nsolver_type::String: type of solver for the transport calculations.\nquadrature_type::String: type of quadrature for the angular domain.\nquadrature_order::Int64: order of the quadrature for the angular domain.\nlegendre_order::Int64: maximum order of the Legendre expansion for the differential cross-sections.\nscheme_type::Dict{String,String}: type of schemes for the spatial or energy discretization.\nscheme_order::Dict{String,Int64}: order of the expansion for the discretization schemes.\n\nOptional field(s) - with default values\n\nangular_fokker_planck::String=\"finite-difference\": type of discretization for the angular Fokker-Planck operation.\nangular_boltzmann::String=\"galerkin-d\": type of discretization for the Boltzmann operation.\nconvergence_criterion::Float64 = 1e-7: convergence criterion of in-group iterations.\nmaximum_iteration::Int64 = 300: maximum number of in-group iterations.\nacceleration::Int64 = \"none\": acceleration method for the in-group iterations.\n\n\n\n\n\n","category":"type"},{"location":"discrete_ordinates/#Methods","page":"Discrete_Ordinates","title":"Methods","text":"","category":"section"},{"location":"discrete_ordinates/","page":"Discrete_Ordinates","title":"Discrete_Ordinates","text":"Radiant.set_particle(this::Radiant.Discrete_Ordinates,particle::String)\nRadiant.set_solver_type(this::Radiant.Discrete_Ordinates,solver_type::String)\nRadiant.set_quadrature(this::Radiant.Discrete_Ordinates,type::String,order::Int64)\nRadiant.set_legendre_order(this::Radiant.Discrete_Ordinates,legendre_order::Int64)\nRadiant.set_angular_fokker_planck(this::Radiant.Discrete_Ordinates,angular_fokker_planck::String)\nRadiant.set_angular_boltzmann(this::Radiant.Discrete_Ordinates,angular_boltzmann::String)\nRadiant.set_convergence_criterion(this::Radiant.Discrete_Ordinates,convergence_criterion::Float64)\nRadiant.set_maximum_iteration(this::Radiant.Discrete_Ordinates,maximum_iteration::Int64)\nRadiant.set_scheme(this::Radiant.Discrete_Ordinates,axis::String,scheme_type::String,scheme_order::Int64)\nRadiant.set_acceleration(this::Radiant.Discrete_Ordinates,acceleration::String)","category":"page"},{"location":"discrete_ordinates/#Radiant.set_particle-Tuple{Discrete_Ordinates,String}","page":"Discrete_Ordinates","title":"Radiant.set_particle","text":"set_particle(this::Discrete_Ordinates,particle::String)\n\nTo set the particle for which the transport discretization method is for. \n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\nparticle::String: particle identifier, which is either:\nparticle = \"photons\": photons.\nparticle = \"electrons\": electrons.\nparticle = \"positrons\": positrons.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_particle(\"electrons\") \n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Radiant.set_solver_type-Tuple{Discrete_Ordinates,String}","page":"Discrete_Ordinates","title":"Radiant.set_solver_type","text":"set_solver_type(this::Discrete_Ordinates,solver_type::String)\n\nTo set the solver for the particle transport.\n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\nsolver_type::String: solver type, which can takes the following values:\nsolver_type = \"BTE\": Boltzmann transport equation\nsolver_type = \"BFP\": Boltzmann Fokker-Planck equation\nsolver_type = \"BCSD\": Boltzmann-CSD equation\nsolver_type = \"FP\": Fokker-Planck equation\nsolver_type = \"CSD\": Continuous slowing-down only equation\nsolver_type = \"BFP-EF\": Boltzmann Fokker-Planck without elastic\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_particle(\"BFP\")\n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Radiant.set_quadrature-Tuple{Discrete_Ordinates,String,Int64}","page":"Discrete_Ordinates","title":"Radiant.set_quadrature","text":"set_quadrature(this::Discrete_Ordinates,type::String,order::Int64)\n\nTo set the quadrature properties for the discretization of the angular domain.\n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\ntype::String: type of quadrature, which can takes the following values:\ntype = \"gauss-legendre\": Gauss-Legendre quadrature (1D Cartesian geometry only)\ntype = \"gauss-lobatto\": Gauss-Lobatto quadrature (1D Cartesian geometry only)\ntype = \"carlson\": Carlson quadrature (2D or 3D Cartesian geometry only)\ntype = \"gauss-legendre-chebychev\": product quadrature between Gauss-Legendre and Chebychev quadratures (2D or 3D Cartesian geometry only)\ntype = \"lebedev\": Lebedev quadrature (2D or 3D Cartesian geometry only)\norder::Int64: order of the quadrature, which is any integer greater than 2.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_quadrature(\"gauss-legendre\",4)\n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Radiant.set_legendre_order-Tuple{Discrete_Ordinates,Int64}","page":"Discrete_Ordinates","title":"Radiant.set_legendre_order","text":"set_legendre_order(this::Discrete_Ordinates,legendre_order::Int64)\n\nTo set the maximum order of the Legendre expansion of the differential cross-sections.\n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\nlegendre_order::Int64: maximum order of the Legendre expansion of the differential cross-sections.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_legendre_order(7)\n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Radiant.set_angular_fokker_planck-Tuple{Discrete_Ordinates,String}","page":"Discrete_Ordinates","title":"Radiant.set_angular_fokker_planck","text":"set_angular_fokker_planck(this::Discrete_Ordinates,angular_fokker_planck::String)\n\nTo set the discretization method for the angular Fokker-Planck term.\n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\nangular_fokker_planck::String: discretization method for the angular Fokker-Planck term, which can takes the following values:\nangular_fokker_planck = \"finite-difference\": finite difference discretization.\nangular_fokker_planck = \"galerkin\": galerkin moment-based discretization.\nangular_fokker_planck = \"differential-quadrature\": finite difference discretization (1D Cartesian geometry only).\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_angular_fokker_planck(\"differential-quadrature\")\n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Radiant.set_angular_boltzmann-Tuple{Discrete_Ordinates,String}","page":"Discrete_Ordinates","title":"Radiant.set_angular_boltzmann","text":"set_angular_boltzmann(this::Discrete_Ordinates,angular_boltzmann::String)\n\nTo set the angular discretization method for the Boltzmann operator.\n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\nangular_boltzmann::String: angular discretization method for the Boltzmann operator, which can takes the following values:\nangular_boltzmann = \"standard\": standard discrete ordinates (SN) method.\nangular_boltzmann = \"galerkin-m\": Galerkin method by inversion of the discrete-to-moment M matrix.\nangular_boltzmann = \"galerkin-d\": Galerkin method by inversion of the moment-to-discrete D matrix.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_angular_boltzmann(\"standard\")\n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Radiant.set_convergence_criterion-Tuple{Discrete_Ordinates,Float64}","page":"Discrete_Ordinates","title":"Radiant.set_convergence_criterion","text":"set_convergence_criterion(this::Discrete_Ordinates,convergence_criterion::Float64)\n\nTo set the convergence criterion for the in-group iterations.\n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\nconvergence_criterion::Float64: convergence criterion.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_convergence_criterion(1e-5)\n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Radiant.set_maximum_iteration-Tuple{Discrete_Ordinates,Int64}","page":"Discrete_Ordinates","title":"Radiant.set_maximum_iteration","text":"set_maximum_iteration(this::Discrete_Ordinates,maximum_iteration::Int64)\n\nTo set the maximum number of in-group iterations.\n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\nmaximum_iteration::Int64: maximum number of in-group iterations.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_maximum_iteration(50)\n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Radiant.set_scheme-Tuple{Discrete_Ordinates,String,String,Int64}","page":"Discrete_Ordinates","title":"Radiant.set_scheme","text":"set_scheme(this::Discrete_Ordinates,axis::String,scheme_type::String,scheme_order::Int64)\n\nTo set the type of discretization scheme for derivative along the specified spatial or energy axis.\n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\naxis::String: variable of the derivative for which the scheme is applied, which can takes the following values:\naxis = \"x\": spatial x axis (discretization of the streaming term)\naxis = \"y\": spatial y axis (discretization of the streaming term)\naxis = \"z\": spatial z axis (discretization of the streaming term)\naxis = \"E\": spatial E axis (discretization of the continuous slowing-down term)\nscheme_type::String: type of scheme to be applied, which can takes the following values:\nscheme_type = \"DD\": diamond difference scheme (any order)\nscheme_type = \"DG\": discontinuous Galerkin scheme (any order)\nscheme_type = \"AWD\": adaptive weighted scheme (1st and 2nd order only)\nscheme_order::Int64: scheme order, which takes values greater than 1.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_scheme(\"x\",\"DD\",1)\njulia> m.set_scheme(\"E\",\"DG\",2)\n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Radiant.set_acceleration-Tuple{Discrete_Ordinates,String}","page":"Discrete_Ordinates","title":"Radiant.set_acceleration","text":"set_acceleration(this::Discrete_Ordinates,acceleration::String)\n\nTo set the acceleration method for the in-group iteration process.\n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\nacceleration::String: acceleration method, which takes the following values\nacceleration = \"none\": none\nacceleration = \"livolant\": livolant acceleration method\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_acceleration(\"livolant\")\n\n\n\n\n\n","category":"method"},{"location":"transport_calculations/#Transport-calculations","page":"Transport calculations","title":"Transport calculations","text":"","category":"section"},{"location":"transport_calculations/","page":"Transport calculations","title":"Transport calculations","text":"RADIANT can compute the coupled transport of particles.","category":"page"},{"location":"transport_calculations/#Example-1:-Coupled-transport-of-photons-electrons-positrons-for-an-electron-beam-normally-incident-on-1D-water-slab","page":"Transport calculations","title":"Example 1: Coupled transport of photons-electrons-positrons for an electron beam normally incident on 1D water slab","text":"","category":"section"},{"location":"transport_calculations/","page":"Transport calculations","title":"Transport calculations","text":"The 'water' and 'cs' types come from Example 1: Production of coupled photons-electrons-positrons cross-sections in water","category":"page"},{"location":"transport_calculations/","page":"Transport calculations","title":"Transport calculations","text":"# Define geometry\ngeo = Geometry()\ngeo.set_type(\"Cartesian\")\ngeo.set_dimension(1)\ngeo.set_material_per_region([water])\ngeo.set_boundary_conditions(\"X-\",\"void\")\ngeo.set_boundary_conditions(\"X+\",\"void\")\ngeo.set_number_of_regions(\"X\",1)\ngeo.set_voxels_per_region(\"X\",[80])\ngeo.set_region_boundaries(\"X\",[0.0,10.0])\ngeo.build(cs)\n\n# Define discretization methods for transport solver\nm1 = Discrete_Ordinates()\nm1.set_particle(\"photons\")\nm1.set_solver_type(\"BFP\")\nm1.set_acceleration(\"livolant\")\nm1.set_quadrature(\"Gauss-Lobatto\",8)\nm1.set_legendre_order(7)\nm1.set_angular_boltzmann(\"galerkin-d\")\nm1.set_convergence_criterion(1e-5)\nm1.set_maximum_iteration(200)\nm1.set_scheme(\"x\",\"DG\",2)\n\nm2 = Discrete_Ordinates()\nm2.set_particle(\"electrons\")\nm2.set_solver_type(\"BFP\")\nm2.set_acceleration(\"livolant\")\nm2.set_quadrature(\"Gauss-Lobatto\",8)\nm2.set_legendre_order(7)\nm2.set_angular_boltzmann(\"galerkin-d\")\nm2.set_angular_fokker_planck(\"finite-difference\")\nm2.set_convergence_criterion(1e-5)\nm2.set_maximum_iteration(200)\nm2.set_scheme(\"E\",\"DG\",2)\nm2.set_scheme(\"x\",\"DG\",2)\n\nm3 = Discrete_Ordinates()\nm3.set_particle(\"positrons\")\nm3.set_solver_type(\"BFP\")\nm3.set_acceleration(\"livolant\")\nm3.set_quadrature(\"Gauss-Lobatto\",8)\nm3.set_legendre_order(7)\nm3.set_angular_boltzmann(\"galerkin-d\")\nm3.set_angular_fokker_planck(\"finite-difference\")\nm3.set_convergence_criterion(1e-5)\nm3.set_maximum_iteration(200)\nm3.set_scheme(\"E\",\"DG\",2)\nm3.set_scheme(\"x\",\"DG\",2)\n\nsolvers = Solvers()\nsolvers.add_solver(m1)\nsolvers.add_solver(m2)\nsolvers.add_solver(m3)\nsolvers.set_number_of_generations(2)\n\n# Define fixed external sources\nss = Surface_Source()\nss.set_particle(\"electrons\")\nss.set_intensity(1.0)\nss.set_energy_group(1)\nss.set_direction([1.0,0.0,0.0])\nss.set_location(\"X-\")\n\ns = Fixed_Sources(cs,geo,solvers)\ns.add_source(ss)\n\n# Consolidate the computation parameters and solve the transport problem\nc1 = Computation_Unit()\nc1.set_cross_sections(cs)\nc1.set_geometry(geo)\nc1.set_solvers(solvers)\nc1.set_sources(s)\nc1.run()\n\n# Dose and energy spectrum solutions\nx = c1.get_voxels_position(\"x\")\nE_γ = c1.get_energies(\"photons\")\nE_e = c1.get_energies(\"electrons\")\nE_p = c1.get_energies(\"positrons\")\ndose = c1.get_energy_deposition(\"total\")\nflux_γ = c1.get_flux(\"photons\")\nflux_e = c1.get_flux(\"electrons\")\nflux_p = c1.get_flux(\"positrons\")\n","category":"page"},{"location":"#Radiant.jl","page":"Radiant.jl","title":"Radiant.jl","text":"","category":"section"},{"location":"cross_sections/#Structure","page":"Cross_Sections","title":"Structure","text":"","category":"section"},{"location":"cross_sections/","page":"Cross_Sections","title":"Cross_Sections","text":"Radiant.Cross_Sections","category":"page"},{"location":"cross_sections/#Radiant.Cross_Sections","page":"Cross_Sections","title":"Radiant.Cross_Sections","text":"Cross_Sections\n\nStructure used to define the parameters to extract or build a multigroup cross-sections library.\n\nMandatory field(s)\n\nname::String: name (or identifier) of the Cross_Sections structure.\nsource::String: source of the cross-sections.\nif source = \"FMAC-M\"\nfile::String: file containing cross-sections data.\nmaterials::Vector{Material}: material list.\nif source = \"RADIANT\"\nmaterials::Vector{Material}: material list.\nparticles::Vector{String}: particle list.\nenergy::Float64: midpoint energy of the highest energy group [in MeV].\nnumber_of_groups::Int64: number of energy groups.\ngroup_structure::String=\"log\": type of group discretization.\nlegendre_order::Int64: maximum order of the angular Legendre moments of the differential cross-sections.\ninteractions::Vector{Interaction}: list of interaction.\n\nOptional field(s) - with default values\n\ncutoff::Float64=0.001: lower energy bound of the lowest energy group (cutoff energy) [in MeV].\n\n\n\n\n\n","category":"type"},{"location":"cross_sections/#Methods","page":"Cross_Sections","title":"Methods","text":"","category":"section"},{"location":"cross_sections/","page":"Cross_Sections","title":"Cross_Sections","text":"Radiant.set_source(this::Radiant.Cross_Sections,source::String)\nRadiant.set_file(this::Radiant.Cross_Sections,file::String)\nRadiant.set_materials(this::Radiant.Cross_Sections,materials::Vector{Radiant.Material})\nRadiant.set_particles(this::Radiant.Cross_Sections,particles::Vector{String})\nRadiant.set_energy(this::Radiant.Cross_Sections,energy::Real)\nRadiant.set_cutoff(this::Radiant.Cross_Sections,cutoff::Real)\nRadiant.set_number_of_groups(this::Radiant.Cross_Sections,number_of_groups::Vector{Int64})\nRadiant.set_group_structure(this::Radiant.Cross_Sections,group_structure::Vector{String})\nRadiant.set_interactions(this::Radiant.Cross_Sections,interactions::Vector{Radiant.Interaction})\nRadiant.set_solvers(this::Radiant.Cross_Sections,solvers::Vector{String})\nRadiant.set_legendre_order(this::Radiant.Cross_Sections,legendre_order::Int64)\nRadiant.build(this::Radiant.Cross_Sections)\nRadiant.write(this::Radiant.Cross_Sections,file::String)","category":"page"},{"location":"cross_sections/#Radiant.set_source-Tuple{Cross_Sections,String}","page":"Cross_Sections","title":"Radiant.set_source","text":"set_source(this::Cross_Sections,source::String)\n\nTo define the source of the cross-sections library.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\nsource::String: source of the cross-sections library which is either:\nsource = \"RADIANT\": multigroup cross-sections are produced by Radiant\nsource = \"FMAC-M\": multigroup cross-sections are extracted from FMAC-M file.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> cs.set_source(\"FMAC-M\")\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.set_file-Tuple{Cross_Sections,String}","page":"Cross_Sections","title":"Radiant.set_file","text":"set_file(this::Cross_Sections,file::String)\n\nTo read a FMAC-M formatted file containing the cross-sections library.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\nfile::String: file name and directory.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> cs.set_file(\"fmac_m.txt\")\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.set_materials-Tuple{Cross_Sections,Array{Material,1}}","page":"Cross_Sections","title":"Radiant.set_materials","text":"set_materials(this::Cross_Sections,materials::Vector{Material})\n\nTo set the list of material, either contained in FMAC-M file in order, or to produce in Radiant.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\nmaterials::Vector{Material}: material list.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> mat1 = Material(); mat2 = Material()\njulia> ... # Defining the material properties\njulia> cs = Cross_Sections()\njulia> cs.set_materials([mat1,mat2])\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.set_particles-Tuple{Cross_Sections,Array{String,1}}","page":"Cross_Sections","title":"Radiant.set_particles","text":"set_particles(this::Cross_Sections,particles::Union{Vector{String},String})\n\nTo set the list of particles for which to produce coupled library of cross-sections.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\nparticles::Vector{String}: particles list, where each particle is either:\nparticles[i] = \"photons\": photons production and interaction are taken into account.\nparticles[i] = \"electrons\": electrons production and interaction are taken into account.\nparticles[i] = \"positrons\": positrons production and interaction are taken into account.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> cs.set_particles([\"electrons\",\"photons\",\"positrons\"])\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.set_energy-Tuple{Cross_Sections,Real}","page":"Cross_Sections","title":"Radiant.set_energy","text":"set_energy(this::Cross_Sections,energy::Real)\n\nTo set the midpoint energy of the highest energy group.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\nenergy::Real: midpoint energy of the highest energy group.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> cs.set_energy(3.0)\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.set_cutoff-Tuple{Cross_Sections,Real}","page":"Cross_Sections","title":"Radiant.set_cutoff","text":"set_cutoff(this::Cross_Sections,cutoff::Real)\n\nTo set the cutoff energy (lower bound of the lowest energy group).\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\ncutoff::Real: cutoff energy (lower bound of the lowest energy group)\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> cs.set_cutoff(0.05)\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.set_number_of_groups-Tuple{Cross_Sections,Array{Int64,1}}","page":"Cross_Sections","title":"Radiant.set_number_of_groups","text":"set_number_of_groups(this::Cross_Sections,number_of_groups::Vector{Int64})\n\nTo set the number of energy groups per particle.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\nnumber_of_groups::Vector{Int64}: number of energy groups per particle in order with the particle list.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> cs.set_particles([\"electrons\",\"photons\",\"positrons\"])\njulia> cs.set_number_of_groups([80,20,80]) # 80 groups with leptons, 20 with photons\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.set_group_structure-Tuple{Cross_Sections,Array{String,1}}","page":"Cross_Sections","title":"Radiant.set_group_structure","text":"set_group_structure(this::Cross_Sections,group_structure::Union{Vector{String},String})\n\nTo set the type of energy discretization structure per particle.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\ngroup_structure::Vector{String}: type of energy discretization structure per particle, where value per particle can take the following value:\ngroup_structure[i] = \"linear\": linearly spaced discretization.\ngroup_structure[i] = \"log\": logarithmically spaced discretization.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> cs.set_particles([\"electrons\",\"photons\",\"positrons\"])\njulia> cs.set_group_structure([\"log\",\"linear\",\"log\"]) # 80 groups with leptons, 20 with photons\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.set_interactions-Tuple{Cross_Sections,Array{Radiant.Interaction,1}}","page":"Cross_Sections","title":"Radiant.set_interactions","text":"set_interactions(this::Cross_Sections,interactions::Vector{Interaction})\n\nTo set the interaction to take into account in the library of cross-sections.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\ninteractions::Vector{Interaction}: list of interactions to use in the production of the cross-sections library.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> cs.set_particles([\"electrons\"])\njulia> cs.set_interactions([Elastic_Leptons(),Inelastic_Leptons(),Bremsstrahlung(), Auger()])\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.set_legendre_order-Tuple{Cross_Sections,Int64}","page":"Cross_Sections","title":"Radiant.set_legendre_order","text":"set_legendre_order(this::Cross_Sections,legendre_order::Int64)\n\nTo set the maximum order of the Legendre expansion of the differential cross-sections.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\nlegendre_order::Int64: maximum order of the Legendre expansion of the differential cross-sections.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> cs.set_legendre_order(7)\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.build-Tuple{Cross_Sections}","page":"Cross_Sections","title":"Radiant.build","text":"build(this::Cross_Sections)\n\nTo build the cross-section library.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> ... # Defining the cross-sections library properties\njulia> cs.build()\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.write-Tuple{Cross_Sections,String}","page":"Cross_Sections","title":"Radiant.write","text":"write(this::Cross_Sections,file::String)\n\nTo write a FMAC-M formatted file containing the cross-sections library.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\nfile::String: file name and directory.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> ... # Defining the cross-sections library properties\njulia> cs.write(\"fmac_m.txt\")\n\n\n\n\n\n","category":"method"}]
}
