var documenterSearchIndex = {"docs":
[{"location":"fixed_source/#Structure","page":"Fixed_Sources","title":"Structure","text":"","category":"section"},{"location":"fixed_source/","page":"Fixed_Sources","title":"Fixed_Sources","text":"Radiant.Fixed_Sources","category":"page"},{"location":"fixed_source/#Radiant.Fixed_Sources","page":"Fixed_Sources","title":"Radiant.Fixed_Sources","text":"Fixed_Sources\n\nStructure used to define a collection of fixed sources and their properties.\n\nUser-defined field(s)\n\nMandatory field(s)\nsources_list::Vector{Source}: list of VolumeSource or SurfaceSource sources.\ncross_sections: Cross_Sections structure.\ngeometry: Geometry structure.\nmethods: CoupledTransportSolvers structure.\nOptional field(s) - with default values   N/A\n\nSystem-defined field(s)\n\nnumber_of_particles::Int64: number of particle with fixed sources.\nparticles::Vector{String}: particles associated with fixed sources.\nnormalization_factor::Float64: normalization over the number of particles.\nsources_names: names (or identifier) of the Source objects\n\n\n\n\n\n","category":"type"},{"location":"fixed_source/#Methods","page":"Fixed_Sources","title":"Methods","text":"","category":"section"},{"location":"fixed_source/","page":"Fixed_Sources","title":"Fixed_Sources","text":"Radiant.add_source(this::Radiant.Fixed_Sources,fixed_source::Union{Radiant.Surface_Source,Radiant.Volume_Source})","category":"page"},{"location":"fixed_source/#Radiant.add_source-Tuple{Fixed_Sources,Union{Surface_Source, Volume_Source}}","page":"Fixed_Sources","title":"Radiant.add_source","text":"add_source(this::Fixed_Sources,fixed_source::Union{Surface_Source,Volume_Source})\n\nTo add a surface or volume source to the Fixed_Sources structure.\n\nInput Argument(s)\n\nthis::Fixed_Sources: collection of fixed sources.\nfixed_source::Union{Surface_Source,Volume_Source}: volume or surface source.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> vs = Volume_Source()\njulia> ... # Define the volume source properties\njulia> fs = Fixed_Sources()\njulia> fs.add_source(vs)\n\n\n\n\n\n","category":"method"},{"location":"surface_source/#Structure","page":"Surface_Source","title":"Structure","text":"","category":"section"},{"location":"surface_source/","page":"Surface_Source","title":"Surface_Source","text":"Radiant.Surface_Source","category":"page"},{"location":"surface_source/#Radiant.Surface_Source","page":"Surface_Source","title":"Radiant.Surface_Source","text":"Surface_Source\n\nStructure used to define a directionnal boundary source and its properties.\n\nUser-defined field(s)\n\nMandatory field(s)\nname::String: name (or identifier) of the Surface_Source structure.\nparticle::String: type of particle emitted.\nenergy_group::Int64: energy group index in which the particle are emitted.\ndirection::Vector{Float64}: direction cosine.\nlocation::String: boundary at which the source is located.\nboundaries::Vector{Float64}: boundaries of the source along each axis [in cm].\nOptional field(s) - with default values\nintensity::Float64=1.0: intensity [# particles/cm⁽ᴺ⁻¹⁾, where N is the geometry dimension].\n\nSystem-defined field(s)\n\nis_build::Bool: boolean value defining if the MultigroupCrossSections was build or not.\nsurface_sources::Array{Union{Array{Float64},Float64}}: formatted object for transport calculations.\nnormalization_factor::Float64: normalization over the number of particles.\n\n\n\n\n\n","category":"type"},{"location":"surface_source/#Methods","page":"Surface_Source","title":"Methods","text":"","category":"section"},{"location":"surface_source/","page":"Surface_Source","title":"Surface_Source","text":"Radiant.set_particle(this::Radiant.Surface_Source,particle::String)\nRadiant.set_intensity(this::Radiant.Surface_Source,intensity::Real)\nRadiant.set_energy_group(this::Radiant.Surface_Source,energy_group::Int64)\nRadiant.set_direction(this::Radiant.Surface_Source,direction::Vector{Float64})\nRadiant.set_location(this::Radiant.Surface_Source,location::String)\nRadiant.set_boundaries(this::Radiant.Surface_Source,axis::String,boundaries::Vector{Float64})","category":"page"},{"location":"surface_source/#Radiant.set_particle-Tuple{Surface_Source,String}","page":"Surface_Source","title":"Radiant.set_particle","text":"set_particle(this::Surface_Source,particle::String)\n\nTo define the source particle.\n\nInput Argument(s)\n\nthis::Surface_Source: surface source.\nparticle::String: type of particle, which can takes the following values:\nparticle = \"photons\": photons.\nparticle = \"electrons\": electrons.\nparticle = \"positrons\": positrons.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> ss = Surface_Source()\njulia> ss.set_particle(\"electrons\")\n\n\n\n\n\n","category":"method"},{"location":"surface_source/#Radiant.set_intensity-Tuple{Surface_Source,Real}","page":"Surface_Source","title":"Radiant.set_intensity","text":"set_intensity(this::Surface_Source,intensity::Real)\n\nTo define the intensity of the source.\n\nInput Argument(s)\n\nthis::Surface_Source: surface source.\nintensity::Float64: intensity [# particles/cmᴺ, where N is the geometry dimension]\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> ss = Surface_Source()\njulia> ss.set_intensity(100)\n\n\n\n\n\n","category":"method"},{"location":"surface_source/#Radiant.set_energy_group-Tuple{Surface_Source,Int64}","page":"Surface_Source","title":"Radiant.set_energy_group","text":"set_energy_group(this::Surface_Source,energy_group::Int64)\n\nTo define the energy of the source by setting the energy group in which they are produced.\n\nInput Argument(s)\n\nthis::Surface_Source: surface source.\nenergy_group::Int64: energy group index.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> ss = Surface_Source()\njulia> ss.set_energy_group(1)\n\n\n\n\n\n","category":"method"},{"location":"surface_source/#Radiant.set_direction-Tuple{Surface_Source,Array{Float64,1}}","page":"Surface_Source","title":"Radiant.set_direction","text":"set_direction(this::Surface_Source,direction::Vector{Float64})\n\nTo set a direction of the source.\n\nInput Argument(s)\n\nthis::Surface_Source: surface source.\ndirection::Vector{Float64}: director cosines [μ,η,ξ]\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> ss = Surface_Source()\njulia> ss.set_direction([1.0,0.0,0.0])\n\n\n\n\n\n","category":"method"},{"location":"surface_source/#Radiant.set_location-Tuple{Surface_Source,String}","page":"Surface_Source","title":"Radiant.set_location","text":"set_location(this::Surface_Source,location::String)\n\nTo set the location of the surface source.\n\nInput Argument(s)\n\nthis::Surface_Source: surface source.\nlocation::String: boundary on which the surface source is, which can takes the following value:\nboundary = \"x-\": the lower bound along x-axis\nboundary = \"x+\": the upper bound along x-axis\nboundary = \"y-\": the lower bound along y-axis\nboundary = \"y+\": the upper bound along y-axis\nboundary = \"z-\": the lower bound along z-axis\nboundary = \"z+\": the upper bound along z-axis\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> ss = Surface_Source()\njulia> ss.set_location(\"x-\")\n\n\n\n\n\n","category":"method"},{"location":"surface_source/#Radiant.set_boundaries-Tuple{Surface_Source,String,Array{Float64,1}}","page":"Surface_Source","title":"Radiant.set_boundaries","text":"set_boundaries(this::Surface_Source,axis::String,boundaries::Vector{Float64})\n\nTo define the boundaries of the source along the specified axis.\n\nInput Argument(s)\n\nthis::Surface_Source: surface source.\naxis::String: axis along which the boundaries are defined.\nboundaries::Vector{Float64}: boundaries of the source in accending order [in cm]\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> ss = Surface_Source()\njulia> ss.set_boundaries(\"x\",[1.0,3.0])\n\n\n\n\n\n","category":"method"},{"location":"computation_unit/#Structure","page":"Computation_Unit","title":"Structure","text":"","category":"section"},{"location":"computation_unit/","page":"Computation_Unit","title":"Computation_Unit","text":"Radiant.Computation_Unit","category":"page"},{"location":"computation_unit/#Radiant.Computation_Unit","page":"Computation_Unit","title":"Radiant.Computation_Unit","text":"Computation_Unit\n\nStructure used to consolidate the cross-sections, geometry, solvers and sources, execute transport calculations and extract its results.\n\nUser-defined field(s)\n\nMandatory field(s)\ncross_sections::Cross_Sections: cross-section library.\ngeometry::Geometry: geometry.\ncoupled_transport_solvers::Coupled_Transport_Solvers: solvers.\nsources::Sources: fixed sources.\nOptional field(s) - with default values\n\nN/A\n\nSystem-defined field(s)\n\nflux::Flux: flux solution.\n\n\n\n\n\n","category":"type"},{"location":"computation_unit/#Methods","page":"Computation_Unit","title":"Methods","text":"","category":"section"},{"location":"computation_unit/","page":"Computation_Unit","title":"Computation_Unit","text":"Radiant.set_cross_sections(this::Radiant.Computation_Unit,cross_sections::Radiant.Cross_Sections)\nRadiant.set_geometry(this::Radiant.Computation_Unit,geometry::Radiant.Geometry)\nRadiant.set_methods(this::Radiant.Computation_Unit,methods::Radiant.Coupled_Transport_Solvers)\nRadiant.set_sources(this::Radiant.Computation_Unit,sources::Radiant.Fixed_Sources)\nRadiant.run(this::Radiant.Computation_Unit)","category":"page"},{"location":"computation_unit/#Radiant.set_cross_sections-Tuple{Computation_Unit,Cross_Sections}","page":"Computation_Unit","title":"Radiant.set_cross_sections","text":"set_cross_sections(this::Computation_Unit,cross_sections::Cross_Sections)\n\nTo set the cross-sections library for transport calculations.\n\nInput Argument(s)\n\nthis::Computation_Unit: computation unit.\ncross_sections::Cross_Sections: cross-sections library.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> ... # Define cross-sections properties and generate multigroup cross-sections.\njulia> cu = Computation_Unit()\njulia> cu.set_cross_sections(cs)\n\n\n\n\n\n","category":"method"},{"location":"computation_unit/#Radiant.set_geometry-Tuple{Computation_Unit,Geometry}","page":"Computation_Unit","title":"Radiant.set_geometry","text":"set_geometry(this::Computation_Unit,geometry::Geometry)\n\nTo set the geometry for transport calculations.\n\nInput Argument(s)\n\nthis::Computation_Unit: computation unit.\ngeometry::Geometry: geometry.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> geo = Geometry()\njulia> ... # Define geometry and its properties\njulia> cu = Computation_Unit()\njulia> cu.set_geometry(geo)\n\n\n\n\n\n","category":"method"},{"location":"computation_unit/#Radiant.set_methods-Tuple{Computation_Unit,Coupled_Transport_Solvers}","page":"Computation_Unit","title":"Radiant.set_methods","text":"set_methods(this::Computation_Unit,coupled_transport_solvers::Coupled_Transport_Solvers)\n\nTo set the discretization coupled_transport_solvers for transport calculations.\n\nInput Argument(s)\n\nthis::Computation_Unit: computation unit.\ncoupled_transport_solvers::Coupled_Transport_Solvers: collection of discretization method per particle.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> ms = Coupled_Transport_Solvers()\njulia> ... # Define all the discretization solvers and their properties\njulia> cu = Computation_Unit()\njulia> cu.set_methods(ms)\n\n\n\n\n\n","category":"method"},{"location":"computation_unit/#Radiant.set_sources-Tuple{Computation_Unit,Fixed_Sources}","page":"Computation_Unit","title":"Radiant.set_sources","text":"set_sources(this::Computation_Unit,sources::Fixed_Sources)\n\nTo set the fixed sources for transport calculations.\n\nInput Argument(s)\n\nthis::Computation_Unit: computation unit.\nsources::Fixed_Sources: collection of fixed sources.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> fs = Fixed_Sources()\njulia> ... # Define all the fixed sources and their properties\njulia> cu = Computation_Unit()\njulia> cu.set_sources(fs)\n\n\n\n\n\n","category":"method"},{"location":"computation_unit/#Radiant.run-Tuple{Computation_Unit}","page":"Computation_Unit","title":"Radiant.run","text":"run(this::Computation_Unit)\n\nTo lauch the transport calculations to solve the transport equation and obtain the flux solution.\n\nInput Argument(s)\n\nthis::Computation_Unit: computation unit.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cu = Computation_Unit()\njulia> ... # Define the cross-sections, geometry, fixed sources and discretization solvers\njulia> cu.run()\n\n\n\n\n\n","category":"method"},{"location":"material/#Structure","page":"Material","title":"Structure","text":"","category":"section"},{"location":"material/","page":"Material","title":"Material","text":"Radiant.Radiant.Material","category":"page"},{"location":"material/#Radiant.Material","page":"Material","title":"Radiant.Material","text":"Material\n\nStructure used to define a material and its properties.\n\nUser-defined field(s)\n\nMandatory field(s)\nname::String: name (or identifier) of the Material structure.\ndensity::Float64: density [in g/cm³].\nelements::Vector{String}: vector of the element in the composition of the material.\nweight_fractions::Vector{Float64}: vector of the weight fraction for each element in the composition of the material.\nOptional field(s) - with default values\nstate_of_matter::String = \"solid\": state of the matter.\n\nSystem-defined field(s)\n\nnumber_of_elements::Int64: number of elements in the composition of the material.\natomic_numbers::Vector{Int64}: vector of the atomic number corresponding to the element in the composition of the material.\n\n\n\n\n\n","category":"type"},{"location":"material/#Methods","page":"Material","title":"Methods","text":"","category":"section"},{"location":"material/","page":"Material","title":"Material","text":"Radiant.set_name(this::Radiant.Material,name::String)\nRadiant.set_density(this::Radiant.Material,density::Real)\nRadiant.set_state_of_matter(this::Radiant.Material,state_of_matter::String)\nRadiant.add_element(this::Radiant.Material,symbol::String,weight_fraction::Real)","category":"page"},{"location":"material/#Radiant.set_name-Tuple{Material,String}","page":"Material","title":"Radiant.set_name","text":"set_name(this::Material,name::String)\n\nTo set the identifier (name) of the Material structure.\n\nInput Argument(s)\n\nthis::Material: material.\nname::String: identifier (name).\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> mat = Material()\njulia> mat.set_name(\"water\")\n\n\n\n\n\n","category":"method"},{"location":"material/#Radiant.set_density-Tuple{Material,Real}","page":"Material","title":"Radiant.set_density","text":"set_density(this::Material,density::Real)\n\nTo set the density of the material.\n\nInput Argument(s)\n\nthis::Material: material.\ndensity::Real: density [in g/cm³].\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> mat = Material()\njulia> mat.set_density(19.3)\n\n\n\n\n\n","category":"method"},{"location":"material/#Radiant.set_state_of_matter-Tuple{Material,String}","page":"Material","title":"Radiant.set_state_of_matter","text":"set_state_of_matter(this::Material,state_of_matter::String)\n\nTo set the state of the matter (solid or liquid or gaz).\n\nInput Argument(s)\n\nthis::Material: material.\nstate_of_matter::String: state of matter, which value is given by \"solid\", \"liquid\" or \"gaz\".\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> mat = Material()\njulia> mat.set_state_of_matter(\"liquid\")\n\n\n\n\n\n","category":"method"},{"location":"material/#Radiant.add_element-Tuple{Material,String,Real}","page":"Material","title":"Radiant.add_element","text":"add_element(this::Material,symbol::String,weight_fraction::Real)\n\nTo add an element which is part of the composition of the material.\n\nInput Argument(s)\n\nthis::Material: material.\nsymbol::String: element symbol, with value such as \"H\", \"He\", etc.\nweight_fraction::Real: weight fraction of the element in the material (between 0 and 1).\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> water = Material()\njulia> water.add_element(\"H\",0.1111)\njulia> water.add_element(\"O\",0.8889)\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Structure","page":"Geometry","title":"Structure","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Radiant.Geometry","category":"page"},{"location":"geometry/#Radiant.Geometry","page":"Geometry","title":"Radiant.Geometry","text":"Geometry\n\nStructure used to define the geometry properties of the medium for transport calculations.\n\nUser-defined field(s)\n\nMandatory field(s)\nname::String: name (or identifier) of the Geometry structure.\ndimension::Int64: dimension of the geometry.\nmaterial_per_region::Array{Material}: multidimensional array of the material per regions.\nboundary_conditions::Dict{String,Int64}: boundary conditions along each axis.\nnumber_of_regions::Dict{String,Int64}: number of regions along each axis.\nvoxels_per_region::Dict{String,Vector{Int64}}: number of voxels inside each regions along each axis.\nregion_boundaries::Dict{String,Vector{Float64}}: boundaries of each regions along each axis.\nOptional field(s) - with default values\ntype::String=\"cartesian\": type of geometry.\n\nSystem-defined field(s)\n\naxis::Vector{String}: vector of the axis related to the geometry.\nnumber_of_voxels::Dict{String,Int64}: total number of voxels along each axis.\nvoxels_width::Dict{String,Vector{Float64}}: width of each voxels along each axis.\nvoxels_position::Dict{String,Vector{Float64}}: midpoint positon of each voxels along each axis.\nmaterial_per_voxel::Array{Int64}: array of the material identifier number per voxel.\nvolume_per_voxel::Array{Float64}: array of the volume per voxel.\nis_build::Bool: boolean value defining if the Geometry was build or not.\n\n\n\n\n\n","category":"type"},{"location":"geometry/#Methods","page":"Geometry","title":"Methods","text":"","category":"section"},{"location":"geometry/","page":"Geometry","title":"Geometry","text":"Radiant.set_type(this::Radiant.Geometry,type::String)\nRadiant.set_dimension(this::Radiant.Geometry,dimension::Int64)\nRadiant.set_boundary_conditions(this::Radiant.Geometry,boundary::String,boundary_condition::String)\nRadiant.set_number_of_regions(this::Radiant.Geometry,axis::String,number_of_regions::Int64)\nRadiant.set_voxels_per_region(this::Radiant.Geometry,axis::String,voxels_per_region::Vector{Int64})\nRadiant.set_region_boundaries(this::Radiant.Geometry,axis::String,region_boundaries::Vector{Float64})\n\nRadiant.set_material_per_region(this::Radiant.Geometry,material_per_region::Array{Radiant.Material})\nRadiant.build(this::Radiant.Geometry,cs::Radiant.Cross_Sections)","category":"page"},{"location":"geometry/#Radiant.set_type-Tuple{Geometry,String}","page":"Geometry","title":"Radiant.set_type","text":"set_type(this::Geometry,type::String)\n\nTo set the type of geometry.\n\nInput Argument(s)\n\nthis::Geometry: geometry.\ntype::String: type of geometry, which can takes the following value:   -type = \"cartesian\": Cartesian geometry.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> geo = Geometry()\njulia> geo.set_type(\"cartesian\")\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Radiant.set_dimension-Tuple{Geometry,Int64}","page":"Geometry","title":"Radiant.set_dimension","text":"set_dimension(this::Geometry,dimension::Int64)\n\nTo set the dimension of geometry.\n\nInput Argument(s)\n\nthis::Geometry: geometry.\ndimension::Int64: dimension of the geometry, which can be either 1, 2 or 3.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> geo = Geometry()\njulia> geo.set_dimension(2) # For 2D geometry\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Radiant.set_boundary_conditions-Tuple{Geometry,String,String}","page":"Geometry","title":"Radiant.set_boundary_conditions","text":"set_boundary_conditions(this::Geometry,boundary::String,boundary_condition::String)\n\nTo set the boundary conditions at the specified boundary.\n\nInput Argument(s)\n\nthis::Geometry: geometry.\nboundary::String: boundary for which the boundary condition is applied, which can takes the following value:\nboundary = \"x-\": the lower bound along x-axis\nboundary = \"x+\": the upper bound along x-axis\nboundary = \"y-\": the lower bound along y-axis\nboundary = \"y+\": the upper bound along y-axis\nboundary = \"z-\": the lower bound along z-axis\nboundary = \"z+\": the upper bound along z-axis\nboundary_condition::String: boundary conditions, which can takes the following value:   -boundary = \"void\": void boundary conditions.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> geo = Geometry()\njulia> geo.set_boundary_conditions(\"x-\",\"void\")\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Radiant.set_number_of_regions-Tuple{Geometry,String,Int64}","page":"Geometry","title":"Radiant.set_number_of_regions","text":"set_number_of_regions(this::Geometry,axis::String,number_of_regions::Int64)\n\nTo set the number of regions along a specified axis.\n\nInput Argument(s)\n\nthis::Geometry: geometry.\naxis::String: axis along which the number of regions is specified, which can takes the following values:\nboundary = \"x\": along x-axis\nboundary = \"y\": along y-axis\nboundary = \"z\": along z-axis\nnumber_of_regions::Int64: number of regions.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> geo = Geometry()\njulia> geo.set_number_of_regions(\"x\",3)\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Radiant.set_voxels_per_region-Tuple{Geometry,String,Array{Int64,1}}","page":"Geometry","title":"Radiant.set_voxels_per_region","text":"set_voxels_per_region(this::Geometry,axis::String,voxels_per_region::Vector{Int64})\n\nTo set the number of voxels for each regions along a specified axis.\n\nInput Argument(s)\n\nthis::Geometry: geometry.\naxis::String: axis along which the number of regions is specified, which can takes the following values:\nboundary = \"x\": along x-axis\nboundary = \"y\": along y-axis\nboundary = \"z\": along z-axis\nvoxels_per_region::Vector{Int64}: vector with the number of voxels for each regions along the specified axis.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> geo = Geometry()\njulia> geo.set_number_of_regions(\"x\",3)\njulia> geo.set_voxels_per_region(\"x\",[10,5,2])\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Radiant.set_region_boundaries-Tuple{Geometry,String,Array{Float64,1}}","page":"Geometry","title":"Radiant.set_region_boundaries","text":"set_region_boundaries(this::Geometry,axis::String,region_boundaries::Vector{Float64})\n\nTo set the boundaries of each regions along a specified axis.\n\nInput Argument(s)\n\nthis::Geometry: geometry.\naxis::String: axis along which the number of regions is specified, which can takes the following values:\nboundary = \"x\": along x-axis\nboundary = \"y\": along y-axis\nboundary = \"z\": along z-axis\nregion_boundaries::Vector{Float64}: vector with the regions boundaries along the specified axis in ascending order.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> geo = Geometry()\njulia> geo.set_number_of_regions(\"x\",3)\njulia> geo.set_voxels_per_region(\"x\",[10,5,2])\njulia> geo.set_voxels_per_region(\"x\",[0.0 0.3 0.5 1.0])\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Radiant.set_material_per_region-Tuple{Geometry,Array{Material,N} where N}","page":"Geometry","title":"Radiant.set_material_per_region","text":"set_material_per_region(this::Geometry,material_per_region::Array{Material})\n\nTo set the material in each regions of the geometry.\n\nInput Argument(s)\n\nthis::Geometry: geometry.\nmaterial_per_region::Array{Material}: array containing the material for each regions. Its size should fit the number of regions per axis.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\n# Define material\njulia> mat1 = Material(); mat2 = Material()\njulia> ... # Define the material properties\n\n# 1D geometry case\njulia> geo1D = Geometry()\njulia> geo1D.set_type(\"cartesian\")\njulia> geo1D.set_dimension(1)\njulia> geo1D.set_number_of_regions(\"x\",3)\njulia> geo1D.set_material_per_region([mat1 mat2 mat1])\n\n# 2D geometry case\njulia> geo1D = Geometry()\njulia> geo1D.set_type(\"cartesian\")\njulia> geo1D.set_dimension(2)\njulia> geo1D.set_number_of_regions(\"x\",2)\njulia> geo1D.set_number_of_regions(\"y\",3)\njulia> geo1D.set_material_per_region([mat1 mat2 mat1 ; mat2 mat1 mat2])\n\n\n\n\n\n\n","category":"method"},{"location":"geometry/#Radiant.build-Tuple{Geometry,Cross_Sections}","page":"Geometry","title":"Radiant.build","text":"build(this::Geometry,cs::Cross_Sections)\n\nTo build the geometry structure.\n\nInput Argument(s)\n\nthis::Geometry: geometry.\ncs::Cross_Sections: cross-sections library.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> ... # Defining the cross-sections library properties\njulia> cs.build()\njulia> geo = Geometry()\njulia> ... # Defining the geometry properties\njulia> geo.build(cs)\n\n\n\n\n\n","category":"method"},{"location":"coupled_transport_solvers/#Structure","page":"Coupled_Transport_Solvers","title":"Structure","text":"","category":"section"},{"location":"coupled_transport_solvers/","page":"Coupled_Transport_Solvers","title":"Coupled_Transport_Solvers","text":"Radiant.Coupled_Transport_Solvers","category":"page"},{"location":"coupled_transport_solvers/#Radiant.Coupled_Transport_Solvers","page":"Coupled_Transport_Solvers","title":"Radiant.Coupled_Transport_Solvers","text":"Coupled_Transport_Solvers\n\nStructure used to define the collection of discretization methods for transport calculations associated with each of the particle and additionnal coupled transport informations.\n\nUser-defined field(s)\n\nMandatory field(s)\nmethods_list::Vector{Discrete_Ordinates}: list of the particle methods\nnumber_of_generations::Int64: number of particle generations to transport.\nOptional field(s) - with default values   N/A\n\nSystem-defined field(s)\n\nnumber_of_particles::Int64: number of particle for which methods are described\nparticles::Vector{String}: vector of the particle for which methods are described\nmethods_names::Vector{String}: vector of the names of the particle methods\n\n\n\n\n\n","category":"type"},{"location":"coupled_transport_solvers/#Methods","page":"Coupled_Transport_Solvers","title":"Methods","text":"","category":"section"},{"location":"coupled_transport_solvers/","page":"Coupled_Transport_Solvers","title":"Coupled_Transport_Solvers","text":"Radiant.add_solver(this::Radiant.Coupled_Transport_Solvers,method::Radiant.Discrete_Ordinates)\nRadiant.set_number_of_generations(this::Radiant.Coupled_Transport_Solvers,number_of_generations::Int64)","category":"page"},{"location":"coupled_transport_solvers/#Radiant.add_solver-Tuple{Coupled_Transport_Solvers,Discrete_Ordinates}","page":"Coupled_Transport_Solvers","title":"Radiant.add_solver","text":"add_solver(this::Coupled_Transport_Solvers,method::Discrete_Ordinates)\n\nTo add a particle and is associated methods to the Coupled_Transport_Solvers structure.\n\nInput Argument(s)\n\nthis::Coupled_Transport_Solvers: collection of discretization method.\nmethod::Discrete_Ordinates: discretization method.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> ... # Define the methods properties\njulia> ms = Coupled_Transport_Solvers()\njulia> ms.add_solver(m)\n\n\n\n\n\n","category":"method"},{"location":"coupled_transport_solvers/#Radiant.set_number_of_generations-Tuple{Coupled_Transport_Solvers,Int64}","page":"Coupled_Transport_Solvers","title":"Radiant.set_number_of_generations","text":"set_number_of_generations(this::Coupled_Transport_Solvers,number_of_generations::Int64)\n\nTo set the number of particle generation to transport during calculations\n\nInput Argument(s)\n\nthis::Coupled_Transport_Solvers: collection of discretization method.\nnumber_of_generations::Int64: number of particle generation to transport during calculations.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> ms = Coupled_Transport_Solvers()\njulia> ms.set_number_of_generations(2)\n\n\n\n\n\n","category":"method"},{"location":"volume_source/#Structure","page":"Volume_Source","title":"Structure","text":"","category":"section"},{"location":"volume_source/","page":"Volume_Source","title":"Volume_Source","text":"Radiant.Volume_Source","category":"page"},{"location":"volume_source/#Radiant.Volume_Source","page":"Volume_Source","title":"Radiant.Volume_Source","text":"Volume_Source\n\nStructure used to define an isotropic volume source and its properties.\n\nUser-defined field(s)\n\nMandatory field(s)\nname::String: name (or identifier) of the Volume_Source structure.\nparticle::String: type of particle emitted.\nenergy_group::Int64: energy group index in which the particle are emitted.\nboundaries::Vector{Float64}: boundaries of the source along each axis [in cm].\nOptional field(s) - with default values\nintensity::Float64=1.0: intensity [# particles/cmᴺ, where N is the geometry dimension].\n\nSystem-defined field(s)\n\nis_build::Bool: boolean value defining if the MultigroupCrossSections was build or not.\nvolume_sources::Array{Float64}: formatted array for transport calculations. \nnormalization_factor::Float64: normalization over the number of particles.\n\n\n\n\n\n","category":"type"},{"location":"volume_source/#Methods","page":"Volume_Source","title":"Methods","text":"","category":"section"},{"location":"volume_source/","page":"Volume_Source","title":"Volume_Source","text":"Radiant.set_particle(this::Radiant.Volume_Source,particle::String)\nRadiant.set_intensity(this::Radiant.Volume_Source,intensity::Real)\nRadiant.set_energy_group(this::Radiant.Volume_Source,energy_group::Int64)\nRadiant.set_boundaries(this::Radiant.Volume_Source,axis::String,boundaries::Vector{Float64})","category":"page"},{"location":"volume_source/#Radiant.set_particle-Tuple{Volume_Source,String}","page":"Volume_Source","title":"Radiant.set_particle","text":"set_particle(this::Volume_Source,particle::String)\n\nTo define the source particle.\n\nInput Argument(s)\n\nthis::Volume_Source: volume source.\nparticle::String: type of particle, which can takes the following values:\nparticle = \"photons\": photons.\nparticle = \"electrons\": electrons.\nparticle = \"positrons\": positrons.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> vs = Volume_Source()\njulia> vs.set_particle(\"electrons\")\n\n\n\n\n\n","category":"method"},{"location":"volume_source/#Radiant.set_intensity-Tuple{Volume_Source,Real}","page":"Volume_Source","title":"Radiant.set_intensity","text":"set_intensity(this::Volume_Source,intensity::Real)\n\nTo define the intensity of the source.\n\nInput Argument(s)\n\nthis::Volume_Source: volume source.\nintensity::Float64: intensity [# particles/cmᴺ, where N is the geometry dimension]\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> vs = Volume_Source()\njulia> vs.set_intensity(100)\n\n\n\n\n\n","category":"method"},{"location":"volume_source/#Radiant.set_energy_group-Tuple{Volume_Source,Int64}","page":"Volume_Source","title":"Radiant.set_energy_group","text":"set_energy_group(this::Volume_Source,energy_group::Int64)\n\nTo define the energy of the source by setting the energy group in which they are produced.\n\nInput Argument(s)\n\nthis::Volume_Source: volume source.\nenergy_group::Int64: energy group index.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> vs = Volume_Source()\njulia> vs.set_energy_group(1)\n\n\n\n\n\n","category":"method"},{"location":"volume_source/#Radiant.set_boundaries-Tuple{Volume_Source,String,Array{Float64,1}}","page":"Volume_Source","title":"Radiant.set_boundaries","text":"set_boundaries(this::Volume_Source,axis::String,boundaries::Vector{Float64})\n\nTo define the boundaries of the source along the specified axis.\n\nInput Argument(s)\n\nthis::Volume_Source: volume source.\naxis::String: axis along which the boundaries are defined.\nboundaries::Vector{Float64}: boundaries of the source in accending order [in cm]\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> vs = Volume_Source()\njulia> vs.set_boundaries(\"x\",[1.0,3.0])\n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Structure","page":"Discrete_Ordinates","title":"Structure","text":"","category":"section"},{"location":"discrete_ordinates/","page":"Discrete_Ordinates","title":"Discrete_Ordinates","text":"Radiant.Discrete_Ordinates","category":"page"},{"location":"discrete_ordinates/#Radiant.Discrete_Ordinates","page":"Discrete_Ordinates","title":"Radiant.Discrete_Ordinates","text":"Discrete_Ordinates\n\nStructure used to define the discretization method associated with the transport of a particle.\n\nUser-defined field(s)\n\nMandatory field(s)\nname::String: name (or identifier) of the Discrete_Ordinates structure.\nparticle::String: particle for which the discretization methods is defined\nsolver_type::String: type of solver for the transport calculations.\nquadrature_type::String: type of quadrature for the angular domain.\nquadrature_order::Int64: order of the quadrature for the angular domain.\nlegendre_order::Int64: maximum order of the Legendre expansion for the differential cross-sections.\nscheme_type::Dict{String,String}: type of schemes for the spatial or energy discretization.\nscheme_order::Dict{String,Int64}: order of the expansion for the discretization schemes.\nOptional field(s) - with default values\nangular_fokker_planck::String=\"finite-difference\": type of discretization for the angular Fokker-Planck operation.\nangular_boltzmann::String=\"galerkin-d\": type of discretization for the Boltzmann operation.\nconvergence_criterion::Float64 = 1e-7: convergence criterion of in-group iterations.\nmaximum_iteration::Int64 = 300: maximum number of in-group iterations.\nacceleration::Int64 = \"none\": acceleration method for the in-group iterations.\n\nSystem-defined field(s)\n\nN/A\n\n\n\n\n\n","category":"type"},{"location":"discrete_ordinates/#Methods","page":"Discrete_Ordinates","title":"Methods","text":"","category":"section"},{"location":"discrete_ordinates/","page":"Discrete_Ordinates","title":"Discrete_Ordinates","text":"Radiant.set_particle(this::Radiant.Discrete_Ordinates,particle::String)\nRadiant.set_solver_type(this::Radiant.Discrete_Ordinates,solver_type::String)\nRadiant.set_quadrature(this::Radiant.Discrete_Ordinates,type::String,order::Int64)\nRadiant.set_legendre_order(this::Radiant.Discrete_Ordinates,legendre_order::Int64)\nRadiant.set_angular_fokker_planck(this::Radiant.Discrete_Ordinates,angular_fokker_planck::String)\nRadiant.set_angular_boltzmann(this::Radiant.Discrete_Ordinates,angular_boltzmann::String)\nRadiant.set_convergence_criterion(this::Radiant.Discrete_Ordinates,convergence_criterion::Float64)\nRadiant.set_maximum_iteration(this::Radiant.Discrete_Ordinates,maximum_iteration::Int64)\nRadiant.set_scheme(this::Radiant.Discrete_Ordinates,axis::String,scheme_type::String,scheme_order::Int64)\nRadiant.set_acceleration(this::Radiant.Discrete_Ordinates,acceleration::String)","category":"page"},{"location":"discrete_ordinates/#Radiant.set_particle-Tuple{Discrete_Ordinates,String}","page":"Discrete_Ordinates","title":"Radiant.set_particle","text":"set_particle(this::Discrete_Ordinates,particle::String)\n\nTo set the particle for which the transport discretization method is for. \n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\nparticle::String: particle identifier, which is either:\nparticle = \"photons\": photons.\nparticle = \"electrons\": electrons.\nparticle = \"positrons\": positrons.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_particle(\"electrons\") \n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Radiant.set_solver_type-Tuple{Discrete_Ordinates,String}","page":"Discrete_Ordinates","title":"Radiant.set_solver_type","text":"set_solver_type(this::Discrete_Ordinates,solver_type::String)\n\nTo set the solver for the particle transport.\n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\nsolver_type::String: solver type, which can takes the following values:\nsolver_type = \"BTE\": Boltzmann transport equation\nsolver_type = \"BFP\": Boltzmann Fokker-Planck equation\nsolver_type = \"BCSD\": Boltzmann-CSD equation\nsolver_type = \"FP\": Fokker-Planck equation\nsolver_type = \"CSD\": Continuous slowing-down only equation\nsolver_type = \"BFP-EF\": Boltzmann Fokker-Planck without elastic\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_particle(\"BFP\")\n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Radiant.set_quadrature-Tuple{Discrete_Ordinates,String,Int64}","page":"Discrete_Ordinates","title":"Radiant.set_quadrature","text":"set_quadrature(this::Discrete_Ordinates,type::String,order::Int64)\n\nTo set the quadrature properties for the discretization of the angular domain.\n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\ntype::String: type of quadrature, which can takes the following values:\ntype = \"gauss-legendre\": Gauss-Legendre quadrature (1D Cartesian geometry only)\ntype = \"gauss-lobatto\": Gauss-Lobatto quadrature (1D Cartesian geometry only)\ntype = \"carlson\": Carlson quadrature (2D or 3D Cartesian geometry only)\ntype = \"gauss-legendre-chebychev\": product quadrature between Gauss-Legendre and Chebychev quadratures (2D or 3D Cartesian geometry only)\ntype = \"lebedev\": Lebedev quadrature (2D or 3D Cartesian geometry only)\norder::Int64: order of the quadrature, which is any integer greater than 2.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_quadrature(\"gauss-legendre\",4)\n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Radiant.set_legendre_order-Tuple{Discrete_Ordinates,Int64}","page":"Discrete_Ordinates","title":"Radiant.set_legendre_order","text":"set_legendre_order(this::Discrete_Ordinates,legendre_order::Int64)\n\nTo set the maximum order of the Legendre expansion of the differential cross-sections.\n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\nlegendre_order::Int64: maximum order of the Legendre expansion of the differential cross-sections.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_legendre_order(7)\n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Radiant.set_angular_fokker_planck-Tuple{Discrete_Ordinates,String}","page":"Discrete_Ordinates","title":"Radiant.set_angular_fokker_planck","text":"set_angular_fokker_planck(this::Discrete_Ordinates,angular_fokker_planck::String)\n\nTo set the discretization method for the angular Fokker-Planck term.\n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\nangular_fokker_planck::String: discretization method for the angular Fokker-Planck term, which can takes the following values:\nangular_fokker_planck = \"finite-difference\": finite difference discretization.\nangular_fokker_planck = \"galerkin\": galerkin moment-based discretization.\nangular_fokker_planck = \"differential-quadrature\": finite difference discretization (1D Cartesian geometry only).\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_angular_fokker_planck(\"differential-quadrature\")\n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Radiant.set_angular_boltzmann-Tuple{Discrete_Ordinates,String}","page":"Discrete_Ordinates","title":"Radiant.set_angular_boltzmann","text":"set_angular_boltzmann(this::Discrete_Ordinates,angular_boltzmann::String)\n\nTo set the angular discretization method for the Boltzmann operator.\n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\nangular_boltzmann::String: angular discretization method for the Boltzmann operator, which can takes the following values:\nangular_boltzmann = \"standard\": standard discrete ordinates (SN) method.\nangular_boltzmann = \"galerkin-m\": Galerkin method by inversion of the discrete-to-moment M matrix.\nangular_boltzmann = \"galerkin-d\": Galerkin method by inversion of the moment-to-discrete D matrix.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_angular_boltzmann(\"standard\")\n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Radiant.set_convergence_criterion-Tuple{Discrete_Ordinates,Float64}","page":"Discrete_Ordinates","title":"Radiant.set_convergence_criterion","text":"set_convergence_criterion(this::Discrete_Ordinates,convergence_criterion::Float64)\n\nTo set the convergence criterion for the in-group iterations.\n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\nconvergence_criterion::Float64: convergence criterion.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_convergence_criterion(1e-5)\n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Radiant.set_maximum_iteration-Tuple{Discrete_Ordinates,Int64}","page":"Discrete_Ordinates","title":"Radiant.set_maximum_iteration","text":"set_maximum_iteration(this::Discrete_Ordinates,maximum_iteration::Int64)\n\nTo set the maximum number of in-group iterations.\n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\nmaximum_iteration::Int64: maximum number of in-group iterations.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_maximum_iteration(50)\n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Radiant.set_scheme-Tuple{Discrete_Ordinates,String,String,Int64}","page":"Discrete_Ordinates","title":"Radiant.set_scheme","text":"set_scheme(this::Discrete_Ordinates,axis::String,scheme_type::String,scheme_order::Int64)\n\nTo set the type of discretization scheme for derivative along the specified spatial or energy axis.\n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\naxis::String: variable of the derivative for which the scheme is applied, which can takes the following values:\naxis = \"x\": spatial x axis (discretization of the streaming term)\naxis = \"y\": spatial y axis (discretization of the streaming term)\naxis = \"z\": spatial z axis (discretization of the streaming term)\naxis = \"E\": spatial E axis (discretization of the continuous slowing-down term)\nscheme_type::String: type of scheme to be applied, which can takes the following values:\nscheme_type = \"DD\": diamond difference scheme (any order)\nscheme_type = \"DG\": discontinuous Galerkin scheme (any order)\nscheme_type = \"AWD\": adaptive weighted scheme (1st and 2nd order only)\nscheme_order::Int64: scheme order, which takes values greater than 1.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_scheme(\"x\",\"DD\",1)\njulia> m.set_scheme(\"E\",\"DG\",2)\n\n\n\n\n\n","category":"method"},{"location":"discrete_ordinates/#Radiant.set_acceleration-Tuple{Discrete_Ordinates,String}","page":"Discrete_Ordinates","title":"Radiant.set_acceleration","text":"set_acceleration(this::Discrete_Ordinates,acceleration::String)\n\nTo set the acceleration method for the in-group iteration process.\n\nInput Argument(s)\n\nthis::Discrete_Ordinates: discretization method.\nacceleration::String: acceleration method, which takes the following values\nacceleration = \"none\": none\nacceleration = \"livolant\": livolant acceleration method\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> m = Discrete_Ordinates()\njulia> m.set_acceleration(\"livolant\")\n\n\n\n\n\n","category":"method"},{"location":"#Radiant.jl","page":"Radiant.jl","title":"Radiant.jl","text":"","category":"section"},{"location":"cross_sections/#Structure","page":"Cross_Sections","title":"Structure","text":"","category":"section"},{"location":"cross_sections/","page":"Cross_Sections","title":"Cross_Sections","text":"Radiant.Cross_Sections","category":"page"},{"location":"cross_sections/#Radiant.Cross_Sections","page":"Cross_Sections","title":"Radiant.Cross_Sections","text":"Cross_Sections\n\nStructure used to define the parameters to extract or build a multigroup cross-sections library.\n\nUser-defined field(s)\n\nMandatory field(s)\nname::String: name (or identifier) of the Cross_Sections structure.\nsource::String: source of the cross-sections.\nif source = \"FMAC-M\"\nfile::String: file containing cross-sections data.\nmaterials::Vector{Material}: material list.\nif source = \"RADIANT\"\nmaterials::Vector{Material}: material list.\nparticles::Vector{String}: particle list.\nenergy::Float64: midpoint energy of the highest energy group [in MeV].\nnumber_of_groups::Int64: number of energy groups.\ngroup_structure::String=\"log\": type of group discretization.\nlegendre_order::Int64: maximum order of the angular Legendre moments of the differential cross-sections.\ninteractions::Vector{Interaction}: list of interaction.\nsolvers::Vector{String}: list of solver per particle.\nOptional field(s) - with default values\ncutoff::Float64=0.001: lower energy bound of the lowest energy group (cutoff energy) [in MeV].\n\nSystem-defined field(s)\n\nnumber_of_materials::Int64: number of material.\nnumber_of_particles::Int64: number of particles.\nenergy_boundaries::Vector{Float64}: vector with energy boundaries of the groups [in MeV].\nmultigroup_cross_sections::Array{Multigroup_Cross_Sections}: MultigroupCrossSections structure containing the calculated (or extracted from file) cross-sections data for transport calculations.\nis_build::Bool: boolean value defining if the MultigroupCrossSections was build or not.\n\n\n\n\n\n","category":"type"},{"location":"cross_sections/#Methods","page":"Cross_Sections","title":"Methods","text":"","category":"section"},{"location":"cross_sections/","page":"Cross_Sections","title":"Cross_Sections","text":"Radiant.set_source(this::Radiant.Cross_Sections,source::String)\nRadiant.set_file(this::Radiant.Cross_Sections,file::String)\nRadiant.set_materials(this::Radiant.Cross_Sections,materials::Vector{Radiant.Material})\nRadiant.set_particles(this::Radiant.Cross_Sections,particles::Vector{String})\nRadiant.set_energy(this::Radiant.Cross_Sections,energy::Real)\nRadiant.set_cutoff(this::Radiant.Cross_Sections,cutoff::Real)\nRadiant.set_number_of_groups(this::Radiant.Cross_Sections,number_of_groups::Vector{Int64})\nRadiant.set_group_structure(this::Radiant.Cross_Sections,group_structure::Vector{String})\nRadiant.set_interactions(this::Radiant.Cross_Sections,interactions::Vector{Radiant.Interaction})\nRadiant.set_solvers(this::Radiant.Cross_Sections,solvers::Vector{String})\nRadiant.set_legendre_order(this::Radiant.Cross_Sections,legendre_order::Int64)\nRadiant.build(this::Radiant.Cross_Sections)\nRadiant.write(this::Radiant.Cross_Sections,file::String)","category":"page"},{"location":"cross_sections/#Radiant.set_source-Tuple{Cross_Sections,String}","page":"Cross_Sections","title":"Radiant.set_source","text":"set_source(this::Cross_Sections,source::String)\n\nTo define the source of the cross-sections library.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\nsource::String: source of the cross-sections library which is either:\nsource = \"RADIANT\": multigroup cross-sections are produced by Radiant\nsource = \"FMAC-M\": multigroup cross-sections are extracted from FMAC-M file.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> cs.set_source(\"FMAC-M\")\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.set_file-Tuple{Cross_Sections,String}","page":"Cross_Sections","title":"Radiant.set_file","text":"set_file(this::Cross_Sections,file::String)\n\nTo read a FMAC-M formatted file containing the cross-sections library.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\nfile::String: file name and directory.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> cs.set_file(\"fmac_m.txt\")\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.set_materials-Tuple{Cross_Sections,Array{Material,1}}","page":"Cross_Sections","title":"Radiant.set_materials","text":"set_materials(this::Cross_Sections,materials::Vector{Material})\n\nTo set the list of material, either contained in FMAC-M file in order, or to produce in Radiant.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\nmaterials::Vector{Material}: material list.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> mat1 = Material(); mat2 = Material()\njulia> ... # Defining the material properties\njulia> cs = Cross_Sections()\njulia> cs.set_materials([mat1,mat2])\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.set_particles-Tuple{Cross_Sections,Array{String,1}}","page":"Cross_Sections","title":"Radiant.set_particles","text":"set_particles(this::Cross_Sections,particles::Vector{String})\n\nTo set the list of particles for which to produce coupled library of cross-sections.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\nparticles::Vector{String}: particles list, where each particle is either:\nparticles[i] = \"photons\": photons production and interaction are taken into account.\nparticles[i] = \"electrons\": electrons production and interaction are taken into account.\nparticles[i] = \"positrons\": positrons production and interaction are taken into account.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> cs.set_particles([\"electrons\",\"photons\",\"positrons\"])\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.set_energy-Tuple{Cross_Sections,Real}","page":"Cross_Sections","title":"Radiant.set_energy","text":"set_energy(this::Cross_Sections,energy::Real)\n\nTo set the midpoint energy of the highest energy group.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\nenergy::Real: midpoint energy of the highest energy group.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> cs.set_energy(3.0)\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.set_cutoff-Tuple{Cross_Sections,Real}","page":"Cross_Sections","title":"Radiant.set_cutoff","text":"set_cutoff(this::Cross_Sections,cutoff::Real)\n\nTo set the cutoff energy (lower bound of the lowest energy group).\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\ncutoff::Real: cutoff energy (lower bound of the lowest energy group)\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> cs.set_cutoff(0.05)\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.set_number_of_groups-Tuple{Cross_Sections,Array{Int64,1}}","page":"Cross_Sections","title":"Radiant.set_number_of_groups","text":"set_number_of_groups(this::Cross_Sections,number_of_groups::Vector{Int64})\n\nTo set the number of energy groups per particle.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\nnumber_of_groups::Vector{Int64}: number of energy groups per particle in order with the particle list.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> cs.set_particles([\"electrons\",\"photons\",\"positrons\"])\njulia> cs.set_number_of_groups([80,20,80]) # 80 groups with leptons, 20 with photons\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.set_group_structure-Tuple{Cross_Sections,Array{String,1}}","page":"Cross_Sections","title":"Radiant.set_group_structure","text":"set_group_structure(this::Cross_Sections,group_structure::Vector{String})\n\nTo set the type of energy discretization structure per particle.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\ngroup_structure::Vector{String}: type of energy discretization structure per particle, where value per particle can take the following value:\ngroup_structure[i] = \"linear\": linearly spaced discretization.\ngroup_structure[i] = \"log\": logarithmically spaced discretization.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> cs.set_particles([\"electrons\",\"photons\",\"positrons\"])\njulia> cs.set_group_structure([\"log\",\"linear\",\"log\"]) # 80 groups with leptons, 20 with photons\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.set_interactions-Tuple{Cross_Sections,Array{Radiant.Interaction,1}}","page":"Cross_Sections","title":"Radiant.set_interactions","text":"set_interactions(this::Cross_Sections,interactions::Vector{Interaction})\n\nTo set the interaction to take into account in the library of cross-sections.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\ninteractions::Vector{Interaction}: list of interactions to use in the production of the cross-sections library.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> cs.set_particles([\"electrons\"])\njulia> cs.set_interactions([Elastic_Leptons(),Inelastic_Leptons(),Bremsstrahlung(), Auger()])\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.set_solvers-Tuple{Cross_Sections,Array{String,1}}","page":"Cross_Sections","title":"Radiant.set_solvers","text":"set_solvers(this::Cross_Sections,solvers::Vector{String})\n\nTo set the transport solver per particle.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\nsolvers::Vector{String}: list of the transport to use per particle, which is defined by\nsolvers[i] = \"BTE\": Boltzmann transport equation\nsolvers[i] = \"BFP\": Boltzmann Fokker-Planck equation\nsolvers[i] = \"BCSD\": Boltzmann-CSD equation\nsolvers[i] = \"FP\": Fokker-Planck equation\nsolvers[i] = \"CSD\": Continuous slowing-down only equation\nsolvers[i] = \"BFP-EF\": Boltzmann Fokker-Planck without elastic\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> cs.set_particles([\"electrons\",\"photons\"])\njulia> cs.set_group_structure(\"BFP\",\"BTE\"]) # BFP for electrons, BTE for photons \n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.set_legendre_order-Tuple{Cross_Sections,Int64}","page":"Cross_Sections","title":"Radiant.set_legendre_order","text":"set_legendre_order(this::Cross_Sections,legendre_order::Int64)\n\nTo set the maximum order of the Legendre expansion of the differential cross-sections.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\nlegendre_order::Int64: maximum order of the Legendre expansion of the differential cross-sections.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> cs.set_legendre_order(7)\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.build-Tuple{Cross_Sections}","page":"Cross_Sections","title":"Radiant.build","text":"build(this::Cross_Sections)\n\nTo build the cross-section library.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> ... # Defining the cross-sections library properties\njulia> cs.build()\n\n\n\n\n\n","category":"method"},{"location":"cross_sections/#Radiant.write-Tuple{Cross_Sections,String}","page":"Cross_Sections","title":"Radiant.write","text":"write(this::Cross_Sections,file::String)\n\nTo write a FMAC-M formatted file containing the cross-sections library.\n\nInput Argument(s)\n\nthis::Cross_Sections: cross-sections library.\nfile::String: file name and directory.\n\nOutput Argument(s)\n\nN/A\n\nExamples\n\njulia> cs = Cross_Sections()\njulia> ... # Defining the cross-sections library properties\njulia> cs.write(\"fmac_m.txt\")\n\n\n\n\n\n","category":"method"}]
}
